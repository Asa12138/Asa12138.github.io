[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MetaNet: Network Analysis for Omics Data",
    "section": "",
    "text": "Welcome",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "MetaNet: Network Analysis for Omics Data",
    "section": "Install",
    "text": "Install\nMetaNet is a comprehensive network analysis package, especially in various biological omics.\nSome functions of MetaNet are dependent with pcutils, so you also need to install pcutils.\nThe stable version can be installed from CRAN:\n\ninstall.packages(\"pcutils\")\ninstall.packages(\"MetaNet\")\n\nThe latest development version can be found in https://github.com/Asa12138/MetaNet:\n\nremotes::install_github(\"Asa12138/pcutils\")\nremotes::install_github(\"Asa12138/MetaNet\", dependencies = T)\n\nFor data manipulation, we recommend to use dplyr.\n\nlibrary(MetaNet)\nlibrary(igraph)\n\n# ========data manipulation\nlibrary(dplyr)\nlibrary(pcutils)\n\nMetaNet\nMetaNet is a comprehensive network analysis R package for omics data:\n\nSupport for integrated analysis for multi-omics data.\nCalculate correlation network quickly, accelerate lots of analysis by parallel computing.\nHandle bigger data, more than 10,000 nodes in each omics.\nOffer various layout algorithms for multi-omics network and interfaces to other software (Gephi, Cytoscape, ggplot2), easy to visualize.\nProvide comprehensive topology indexes calculation，including ecological network stability.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#citation",
    "href": "index.html#citation",
    "title": "MetaNet: Network Analysis for Omics Data",
    "section": "Citation",
    "text": "Citation\n\nPlease cite:\nChen Peng (2023). MetaNet: Network Analysis for Omics data. R package, https://github.com/Asa12138/MetaNet.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#quick-start",
    "href": "index.html#quick-start",
    "title": "MetaNet: Network Analysis for Omics Data",
    "section": "Quick Start",
    "text": "Quick Start\nThis is the overall development framework of MetaNet, including data processing, network construction, network analysis, network visualization and other functions:\n\n\n\n\n\n\n\nFigure 1: Overall development framework of MetaNet\n\n\n\n\nSimply build and draw a network plot, only need to use c_net_calculate(), c_net_build(), c_net_plot() three functions:\n\ndata(\"otutab\", package = \"pcutils\")\n\n# Inter-species correlation coefficients were calculated after transposition\ntotu &lt;- t2(otutab[1:100, ])\n\ncor &lt;- c_net_calculate(totu)\nnet &lt;- c_net_build(cor)\nc_net_plot(net)\n\n\n\n\n\n\n\nFor more detailed usage, please refer to the sections below.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#session-info",
    "href": "index.html#session-info",
    "title": "MetaNet: Network Analysis for Omics Data",
    "section": "Session Info",
    "text": "Session Info\n\nsessionInfo()\n## R version 4.2.2 (2022-10-31)\n## Platform: aarch64-apple-darwin20 (64-bit)\n## Running under: macOS 14.7\n## \n## Matrix products: default\n## BLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\n## LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n## \n## locale:\n## [1] C/UTF-8/C/C/C/C\n## \n## attached base packages:\n## [1] stats     graphics  grDevices utils     datasets  methods   base     \n## \n## other attached packages:\n## [1] pcutils_0.2.8 dplyr_1.1.4   MetaNet_0.2.5 igraph_1.6.0 \n## \n## loaded via a namespace (and not attached):\n##  [1] Rcpp_1.0.12        RColorBrewer_1.1-3 pillar_1.9.0       compiler_4.2.2    \n##  [5] plyr_1.8.9         tools_4.2.2        digest_0.6.31      jsonlite_1.8.4    \n##  [9] evaluate_0.19      lifecycle_1.0.4    tibble_3.2.1       gtable_0.3.4      \n## [13] pkgconfig_2.0.3    rlang_1.1.3        cli_3.6.2          yaml_2.3.6        \n## [17] xfun_0.49          fastmap_1.1.0      withr_3.0.0        stringr_1.5.1     \n## [21] knitr_1.45         generics_0.1.3     vctrs_0.6.5        htmlwidgets_1.6.1 \n## [25] grid_4.2.2         tidyselect_1.2.0   glue_1.7.0         R6_2.5.1          \n## [29] fansi_1.0.6        rmarkdown_2.25     ggplot2_3.5.1      reshape2_1.4.4    \n## [33] magrittr_2.0.3     scales_1.3.0       htmltools_0.5.4    colorspace_2.1-0  \n## [37] utf8_1.2.4         stringi_1.8.3      munsell_0.5.0",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "01-introduction.html",
    "href": "01-introduction.html",
    "title": "\n1  Introduction\n",
    "section": "",
    "text": "1.1 Network\nIn mathematics, “networks” are often referred to as “graphs”, and the mathematical field of graph research is called “graph theory”.\nThe basic elements in a network graph are nodes and edges. When constructing a network graph, the objects are called “nodes” (vertices or nodes), and they are usually drawn as points; the connections between nodes are called “edges” (edges or links), and they are usually drawn as lines between points.\nWe can be divide networks into directed and undirected networks, weighted and unweighted networks according to the edges.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "01-introduction.html#network-in-omics",
    "href": "01-introduction.html#network-in-omics",
    "title": "\n1  Introduction\n",
    "section": "\n1.2 Network in omics",
    "text": "1.2 Network in omics\nNetwork can represent various systems in the real world,and it have many applications in biological research, especially in systems biology: gene expression regulatory networks, metabolic networks, ecosystem space networks, microbial co-occurrence networks, protein interaction networks, etc (Figure 1.1).\n\n\n\n\n\n\n\nFigure 1.1: Applications of network in biology\n\n\n\n\nWGCNA\nWeighted Gene Co-expression Network Analysis (WGCNA) is a widely used method to construct gene, protein, or metabolite co-expression networks. It is a systems biology method for describing the correlation patterns among genes across microarray samples.\nWGCNA can be used to find clusters (modules) of highly correlated genes, to summarize such clusters using the module eigengene or an intramodular hub gene, to relate modules to one another and to external sample traits (using eigengene network methodology), and to calculate module membership measures. Correlation networks are first constructed, and then the adjacency matrix is transformed into a topological overlap matrix (TOM) to further enhance the network properties.\nCo-occurrence\nCo-occurrence networks are used to describe the co-occurrence patterns of different species in a community. The nodes in the network represent species, and the edges represent the co-occurrence relationships between species. The co-occurrence network can be used to study the interaction between species in the community, the stability of the community, and the response of the community to environmental changes.\nPPI\nProtein-protein interaction (PPI) networks are used to describe the interactions between proteins. The nodes in the network represent proteins, and the edges represent the interactions between proteins. PPI networks can be used to study the functions of proteins, the pathways in which proteins are involved, and the relationships between proteins.\nMetabolic\nMetabolic networks are used to describe the metabolic pathways in cells. The nodes in the network represent metabolites, and the edges represent the metabolic reactions between metabolites. Metabolic networks can be used to study the metabolic pathways in cells, the relationships between metabolites, and the regulation of metabolic pathways.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "01-introduction.html#software",
    "href": "01-introduction.html#software",
    "title": "\n1  Introduction\n",
    "section": "\n1.3 Software",
    "text": "1.3 Software\nThere are many software packages for network analysis, including R, Python, Pajek, Cytoscape, and Gephi.\n\nR: igraph (https://igraph.org/), network\nPython: networkx (https://pypi.org/project/networkx/)\nPajek (http://vlado.fmf.uni-lj.si/pub/networks/pajek/)\nCytoscape (https://cytoscape.org/)\nGephi (https://gephi.org/)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "02-construction.html",
    "href": "02-construction.html",
    "title": "\n2  Construction\n",
    "section": "",
    "text": "2.1 Pre-processing\nThe trans() function contains many normalization methods, suitable for pre-processing of different omics, some refer to vegan::decostand().\nTable 2.1: Normalization methods used in omics\n\n\n\n\n\nMethod\nDescription\n\n\n\ncpm\nCounts per million\n\n\nminmax\nlinear transfer to (min, max)\n\n\nacpm\nCounts per million, then asinh transfer\n\n\nlog1\n$log(n+1)$ transformat\n\n\ntotal\ndivide by total\n\n\nmax\ndivide by maximum\n\n\nfrequency\ndivide by total and multiply by the number of non-zero items, so that the average of non-zero entries is one.\n\n\nnormalize\nmake margin sum of squares equal to one\n\n\nrange\nstandardize values into range (0,1) (same to minmax(0,1)). If all values are constant, they will be transformed to 0.\n\n\nrank\nrank replaces abundance values by their increasing ranks leaving zeros unchanged.\n\n\nrrank\nrrank is similar but uses relative ranks with maximum 1.\n\n\npa\nscale x to presence/absence scale (0/1).\n\n\nstandardize\nscale x to zero mean and unit variance.\n\n\nhellinger\nsquare root of method = \"total\"\n\n\nlog\nlogarithmic transformation as suggested by Anderson et al. (2006): $log_b(x)+1$ for x&gt;0, where b is the base of the logarithm; zeros are left as zeros.\n\n\nalr\nAdditive log ratio ('alr') transformation (Aitchison 1986) reduces data skewness and compositionality bias.\n\n\nclr\ncentered log ratio ('clr') transformation proposed by Aitchison (1986) reduces data skewness and compositionality bias.\n\n\nrclr\nrobust clr ('rclr') is similar to regular clr (see above) but allows data that contains zeroes.\ntrans(otutab, method = \"log1\") %&gt;% head()\nNS1\nNS2\nNS3\nNS4\nNS5\nNS6\nWS1\nWS2\nWS3\nWS4\nWS5\nWS6\nCS1\nCS2\nCS3\nCS4\nCS5\nCS6\n\n\n\ns__un_f__Thermomonosporaceae\n6.996682\n7.560601\n6.698268\n7.211557\n6.970730\n6.976348\n7.133296\n7.376508\n7.193686\n6.848005\n7.118016\n6.919684\n7.746733\n7.831617\n7.444249\n7.588830\n7.266827\n7.331715\n\n\ns__Pelomonas_puraquae\n7.582229\n7.118826\n7.767687\n7.712891\n7.973844\n7.512071\n6.469250\n6.206576\n7.115582\n7.158514\n6.860664\n6.455199\n7.174724\n7.324490\n6.739337\n7.029088\n7.302496\n7.069023\n\n\ns__Rhizobacter_bergeniae\n6.378426\n6.129050\n6.791221\n6.804614\n7.112327\n6.749931\n6.405228\n6.154858\n6.976348\n6.936343\n6.741701\n6.508769\n6.937314\n7.497207\n6.910751\n7.090910\n7.085902\n6.637258\n\n\ns__Flavobacterium_terrae\n5.501258\n5.459586\n7.501634\n6.513230\n7.276556\n6.198479\n5.765191\n7.563720\n7.309212\n6.903747\n6.359574\n5.886104\n6.985642\n7.105786\n6.626718\n6.049734\n6.940222\n7.253470\n\n\ns__un_g__Rhizobacter\n7.267525\n6.023448\n6.280396\n6.633318\n7.162397\n6.228511\n6.222576\n6.381816\n6.100319\n6.431331\n6.489205\n6.063785\n7.032624\n7.277939\n6.311735\n6.369901\n7.008505\n6.806829\n\n\ns__un_o__Burkholderiales\n6.787845\n6.527958\n6.715383\n6.816736\n7.315218\n6.937314\n5.463832\n5.533390\n5.886104\n5.945421\n5.961005\n5.863631\n6.313548\n6.293419\n6.169611\n6.327937\n6.242223\n6.208590\nrm_low(), guolv() and hebing() functions can help filter or aggregate the omics data.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Construction</span>"
    ]
  },
  {
    "objectID": "02-construction.html#pairwise-relationship",
    "href": "02-construction.html#pairwise-relationship",
    "title": "\n2  Construction\n",
    "section": "\n2.2 Pairwise relationship",
    "text": "2.2 Pairwise relationship\nPairwise relationship is the basis of network construction.\nHow to determine the pairwise relationship, because the experimental data is generally relatively rare, we mainly relying on statistical inference.\nAt present, there are mainly two statistical ways:\n\nSimilarity or correlation (1). For example: Spearman, Pearson, Bray-Curtis, etc. The similarity matrix between paired features can be calculated, and the randomized data can be used to repeatedly calculate the significance. Finally, meaningful similarities are retained in network.\nRegression. Divide features into source and target, and use multiple regression to calculate the relationship between features.\n\nSome tools use special methods to optimize the network construction, such as SparCC, etc.\nCorrelation\nCorrelation is a statistical term describing the degree to which two variables move in coordination with one-another.\nCorrelation calculation is the first step in all omics network analysis software, there are many method to get \\(\\rho\\) and \\(p\\)-value. However, as the data size of omics grow larger and larger, some methods became very time and computational resource consuming.\nHere, we provide the c_net_calculate() function for one single table or two tables to calculate correlation fastly (fig-2-packages-comparison), which will return a coor object including \\(\\rho\\) and \\(p\\)-value.\n\n# single table\nt(otutab) -&gt; totu\nc_net_calculate(totu, method = \"spearman\") -&gt; corr\ncorr\n## Correlation table:\n## Table dimensions: 485 rows, 485 columns\n## Use method:  spearman\n\n\n# two tables\nmetadata[, 3:10] -&gt; env\nc_net_calculate(totu, env, method = \"spearman\") -&gt; corr2\ncorr2\n## Correlation table:\n## Table dimensions: 485 rows, 8 columns\n## Use method:  spearman\n\nIf your input table is too large, the calculation may take a longer time, you can save the result and read it later.\n\nc_net_calculate(matrix(rnorm(1000 * 100), ncol = 1000), method = \"spearman\") -&gt; corr\n\n# save the result\nsave_corr(corr, \"../saved_corr1\")\nread_corr(\"../saved_corr1\") -&gt; corr_new\n\n# they are identical\nidentical(corr, corr_new)\n\nAccording to the test, a table with 1,000 features will cost about 0.2s and to calculate the correlation, and the size of saved .corr file is about 6 MB.\nTime, memory consumption, and saved file size approximately increase linearly with the square of the number of features, as shown in the following figure. By the way, these consumption increase a little bit with the number of samples.\n\nCodefeature_number &lt;- c(100, 500, 1000, 2000, 3000, 4000)\ntime &lt;- c()\nmemory &lt;- c()\nsave_size &lt;- c()\nfor (i in feature_number) {\n  print(i)\n  matrix(rnorm(i * 50), ncol = i) -&gt; tmp\n  system.time({\n    c_net_calculate(tmp, method = \"spearman\") -&gt; tmp_corr\n  }) -&gt; time1\n  time &lt;- c(time, time1[3])\n  memory &lt;- c(memory, object.size(tmp_corr))\n  save_corr(tmp_corr, \"../tmp_corr.corr\")\n  save_size &lt;- c(save_size, file.size(\"../tmp_corr.corr\"))\n}\n\nplot_data &lt;- data.frame(\n  feature_number = feature_number,\n  `time(s)` = time, `memory(MB)` = memory / 1024 / 1024,\n  `save_size(MB)` = save_size / 1024 / 1024, check.names = F\n)\nplot_data &lt;- melt(plot_data, id.vars = \"feature_number\")\n\nggplot(plot_data, aes(x = feature_number, y = value, color = variable)) +\n  geom_line() +\n  geom_point() +\n  facet_wrap(~variable, scales = \"free\") +\n  labs(\n    title = \"Time and memory consumption of `c_net_calculate`\",\n    x = \"feature number\", y = \"value\"\n  ) +\n  theme_bw() +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\nFigure 2.1: Time and memory consumption of c_net_calculate\n\n\n\n\nThe calculation speed of c_net_calculate is much faster than other R packages, especially when the number of features is large:\n\n\n\n\n\n\n\nFigure 2.2: Comparison of correlation calculation speed between different packages\n\n\n\n\nSparCC\nSparCC fits the Dirichlet distribution to the observed data, and iteratively calculates the proportion and correlation of species several times. The resulting correlation is the median of the distribution. \\(p\\)-values were calculated using the bootstrap method.\nThis metric is said to be more useful with non-normal microbiome data.\n\\(D(x_i,x_j)=var(\\log(\\frac{x_i}{x_j}))\\)\n\nc_net_calculate(totu, method = \"sparcc\")\n## NULL corr object.\n\nDistance\nWe should understand the dissimilarity indices (distance) for community. The vegan::vegdist() function provides a wide range of distance metrics based on abundance calculations (Table 2.2). Additionally, there are distance metrics that incorporate phylogenetic data such as “unifrac,” “beta_mpd,” “beta_mntd,” and “phylosor”, etc.\nAnd the similarity indices are the inverse of the distance indices, often as \\(1-distance\\). We can also use c_net_calculate() to calculate the distance. The the similarity indices are more suitable for relationship between samples.\n\nc_net_calculate(otutab, method = \"bray\") -&gt; sim_df\nsim_df\n## Similarity (1-Distance) table:\n## Table dimensions: 18 rows, 18 columns\n## Use method:  bray\n\n\n\n\nTable 2.2: Some dissimilarity indices for community\n\n\n\n\n\nDistance.Coefficient\nDescription\n\n\n\nManhattan\nManhattan distance calculates the sum of absolute differences between coordinates in each dimension. It is suitable for data with categorical variables or attributes.\n\n\nEuclidean\nEuclidean distance calculates the straight-line distance between two points in a multidimensional space. It is commonly used when data are continuous and have no categorical attributes.\n\n\nCanberra\nCanberra distance is a weighted version of Manhattan distance that emphasizes the importance of small differences between coordinates. It is often used for ecological data analysis.\n\n\nClark\nClark distance measures the proportion of non-zero attributes that are different between two samples.\n\n\nBray\nBray distance calculates the dissimilarity between two samples based on the sum of absolute differences in abundances.\n\n\nKulczynski\nKulczynski distance measures the similarity between two samples based on the arithmetic mean of proportions of common attributes.\n\n\nJaccard\nJaccard distance measures dissimilarity between two samples based on the proportion of unique attributes. It is commonly used in ecology for binary data.\n\n\nGower\nGower distance is a generalization of Manhattan distance for mixed data types, including categorical and continuous variables.\n\n\nAltGower\nAltGower distance is an alternative form of Gower distance that uses an alternative method to standardize continuous variables.\n\n\nMorisita\nMorisita distance measures dissimilarity between two samples based on the frequency of shared attributes, with emphasis on rare attributes.\n\n\nHorn\nHorn distance measures dissimilarity between two samples based on the geometric mean of proportions of shared attributes.\n\n\nMountford\nMountford distance measures dissimilarity between two samples based on the reciprocal of the arithmetic mean of proportions of shared attributes.\n\n\nRaup\nRaup distance measures dissimilarity between two samples based on the probability of shared attributes.\n\n\nBinomial\nBinomial distance measures dissimilarity between two samples based on the probability of observing shared attributes.\n\n\nChao\nChao distance is a modification of Jaccard distance that adjusts for undersampling of rare species.\n\n\nCao\nCao distance is a modification of Chao distance that incorporates species abundance information.\n\n\nMahalanobis\nMahalanobis distance measures the distance between two samples in multidimensional space, accounting for correlation between variables.\n\n\nChisq\nChisq distance calculates the dissimilarity between two samples based on the chi-squared distance between categorical variables.\n\n\nChord\nChord distance calculates dissimilarity between two samples based on the angles between points in multidimensional space.\n\n\nHellinger\nHellinger distance measures dissimilarity between two samples based on the square root of the sum of squared differences in square root-transformed abundances.\n\n\nAitchison\nAitchison distance is a transformation of compositional data that allows for Euclidean distance calculation in log-ratio space.\n\n\nRobust Aitchison\nRobust Aitchison distance is a robust version of Aitchison distance that reduces the influence of outliers in the data.\n\n\nUnifrac\nUnifrac distance measures dissimilarity between microbial communities based on evolutionary distances in a phylogenetic tree.\n\n\nBeta MPD\nBeta MPD (Mean Phylogenetic Distance) measures the phylogenetic diversity between two communities based on the mean phylogenetic distance of species pairs.\n\n\nBeta MNTD\nBeta MNTD (Mean Nearest Taxon Distance) measures the phylogenetic turnover between two communities based on the mean nearest taxon distance.\n\n\nPhylosor\nPhylosor distance measures the dissimilarity between communities based on the proportion of shared branches in a phylogenetic tree.\n\n\n\n\n\n\n\n\n\n\nOthers\nThere are some other methods available for network construction in NetCoMi:\n\nBiweight Midcorrelation bicor() from WGCNA package\nCCLasso (R code on GitHub)\nCCREPE (ccrepe package)\nSPRING (SPRING package)\ngCoda (R code on GitHub)\npropr (propr package)\nKullback-Leibler divergence (KLD) (KLD() from LaplacesDemon package)\nJeffrey divergence (own code using KLD() from LaplacesDemon package)\nJensen-Shannon divergence (own code using KLD() from LaplacesDemon package)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Construction</span>"
    ]
  },
  {
    "objectID": "02-construction.html#build-network",
    "href": "02-construction.html#build-network",
    "title": "\n2  Construction\n",
    "section": "\n2.3 Build network",
    "text": "2.3 Build network\nNormally build\nIf you have done the c_net_calculate() step, then you can get a network (metanet object, inherit from igraph object) easily by c_net_build(). Some common attributes will be set automatically.\n\nc_net_build(corr, r_threshold = 0.6, p_threshold = 0.05, delete_single = T) -&gt; co_net\nco_net\n## =================================== metanet ==================================== \n## IGRAPH 83c9230 UNW- 483 1513 -- \n## + attr: n_type (g/c), name (v/c), v_group (v/c), v_class (v/c), size\n## | (v/n), label (v/c), shape (v/c), color (v/c), id (e/n), from (e/c),\n## | to (e/c), weight (e/n), cor (e/n), p.value (e/n), e_type (e/c), width\n## | (e/n), color (e/c), e_class (e/c), lty (e/n)\n## + edges from 83c9230 (vertex names):\n## [1] s__un_f__Thermomonosporaceae--s__Actinocorallia_herbida    \n## [2] s__un_f__Thermomonosporaceae--s__Kribbella_catacumbae      \n## [3] s__un_f__Thermomonosporaceae--s__Kineosporia_rhamnosa      \n## [4] s__un_f__Thermomonosporaceae--s__un_f__Micromonosporaceae  \n## [5] s__un_f__Thermomonosporaceae--s__Flavobacterium_saliperosum\n## + ... omitted several edges\nplot(co_net)\n\n\n\n\n\n\nFigure 2.3: Simple co-occurrence network\n\n\n\n\n\nc_net_build(corr2) -&gt; co_net2\nplot(co_net2)\n\n\n\n\n\n\nFigure 2.4: Simple bipartite network\n\n\n\n\nMulti-tables\nWhen you have more than two tables for correlation network analysis, you can choose the multi_net_build() to calculate and build network.\nFor subsequent multi-omics analysis, see Chapter 7.\n\ndata(\"multi_test\", package = \"MetaNet\")\n# microbiome\ndim(micro)\n## [1] 18 50\n# metabolome\ndim(metab)\n## [1] 18 50\n# transcriptome\ndim(transc)\n## [1] 18 50\n\nmulti_net_build(list(\n  Microbiome = micro,\n  Metabolome = metab,\n  Transcriptome = transc\n)) -&gt; multi1\n\nplot(multi1)\n\n\n\n\n\n\nFigure 2.5: Simple multi-omics network\n\n\n\n\nEdgelist\nIf you already get the pairwise relationship of data from other approaches (database), you can form it into a edgelist and use c_net_from_edgelist to build network. It is useful for following analysis.\n\ndata(\"edgelist\", package = \"MetaNet\")\ndnet &lt;- c_net_from_edgelist(arc_count, direct = T)\nplot(dnet)\n\n\n\n\n\n\nFigure 2.6: Simple directed network\n\n\n\n\nOthers\nIf you have network in other format, such as pajek, lgl, graphml, dimacs, graphdb, gml and dl, you can use read.graph to read it as igraph object. And you can also use graph_from_* functions to get igraph object, then use c_net_update to transform it into metanet object.\ng1 &lt;- graph_from_lcf(12, c(5, -5), 6)\nclass(g1)\n## [1] \"igraph\"\nplot(g1)\n\nc_net_update(g1) -&gt; g2\nclass(g2)\n## [1] \"metanet\" \"igraph\"\nplot(g2)\n\n\n\n\n\n\n\n\n\n(a) igraph plot\n\n\n\n\n\n\n\n\n\n(b) metanet plot\n\n\n\n\n\n\nFigure 2.7: igraph plot and metanet plot",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Construction</span>"
    ]
  },
  {
    "objectID": "02-construction.html#rmt-optimization",
    "href": "02-construction.html#rmt-optimization",
    "title": "\n2  Construction\n",
    "section": "\n2.4 RMT optimization",
    "text": "2.4 RMT optimization\nThe correlation-based relevance network method is most commonly used largely due to its simple calculation procedure and noise tolerance. However, most studies involving relevance network analysis use arbitrary thresholds (usually, we use r&gt;0.6, p&lt;0.05), and thus the constructed networks are subjective rather than objective.\nThis problem has been partially solved by a random matrix theory (RMT)-based approach (Figure 2.8), which is able to automatically identify a proper threshold for network construction from micro-array data (also other omics data) (2).\n\n\n\n\n\n\n\nFigure 2.8: Random matrix theory (RMT)-based approach\n\n\n\n\nuse RMT_threshold() , we can find a proper r_threshold to build the network with smallest noise.\nthe bigger log_LE, less log_LW, less log_see, bigger p_ks_test indicate the better r_threshold for a meaningful network construction.You can change the threshold range to calculate more finely.\n\nRMT_threshold(corr,\n  out_dir = \"../RMT_temp/\",\n  min_threshold = 0.5, max_threshold = 0.9, step = 0.02,\n  verbose = T\n) -&gt; rmt_res\nplot(rmt_res)\n\n\n\n\n\n\n\n\nFigure 2.9: RMT_threshold result from 0.5 to 0.9\n\n\n\n\nYou can set the gif=TRUE in RMT_threshold() and get a gif file to observe the distribution of eigenvalue spacing for different r-thresholds.\n\n\n\n\n\n\n\nFigure 2.10: the distribution of eigenvalue spacing from 0.5 to 0.9\n\n\n\n\n\n\n\n\n1. \nK. Faust, J. Raes, Microbial interactions: From networks to models. Nature Reviews Microbiology (2012), doi:10.1038/nrmicro2832.\n\n\n2. \nY. Deng, Y. Jiang, Y. Yang, Z. He, et al., Molecular ecological network analyses. BMC bioinformatics (2012), doi:10.1186/1471-2105-13-113.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Construction</span>"
    ]
  },
  {
    "objectID": "03-manipulation.html",
    "href": "03-manipulation.html",
    "title": "\n3  Manipulation\n",
    "section": "",
    "text": "3.1 Attributes\nWe could get the attributes of whole network, each vertex and each edge by get_*() as data.frame:\n# get network attributes\nget_n(co_net)\n##   n_type\n## 1 single\n# get vertex attributes\nget_v(co_net) %&gt;% head(5)\n##                           name  v_group  v_class size\n## 1 s__un_f__Thermomonosporaceae v_group1 v_class1    4\n## 2        s__Pelomonas_puraquae v_group1 v_class1    4\n## 3     s__Rhizobacter_bergeniae v_group1 v_class1    4\n## 4     s__Flavobacterium_terrae v_group1 v_class1    4\n## 5         s__un_g__Rhizobacter v_group1 v_class1    4\n##                          label  shape   color\n## 1 s__un_f__Thermomonosporaceae circle #a6bce3\n## 2        s__Pelomonas_puraquae circle #a6bce3\n## 3     s__Rhizobacter_bergeniae circle #a6bce3\n## 4     s__Flavobacterium_terrae circle #a6bce3\n## 5         s__un_g__Rhizobacter circle #a6bce3\n# get edge attributes\nget_e(co_net) %&gt;% head(5)\n##   id                         from                            to    weight\n## 1  1 s__un_f__Thermomonosporaceae     s__Actinocorallia_herbida 0.6759546\n## 2  2 s__un_f__Thermomonosporaceae       s__Kribbella_catacumbae 0.6742386\n## 3  3 s__un_f__Thermomonosporaceae       s__Kineosporia_rhamnosa 0.7378741\n## 4  4 s__un_f__Thermomonosporaceae   s__un_f__Micromonosporaceae 0.6236449\n## 5  5 s__un_f__Thermomonosporaceae s__Flavobacterium_saliperosum 0.6045747\n##         cor      p.value   e_type     width   color  e_class lty\n## 1 0.6759546 0.0020739524 positive 0.6759546 #48A4F0 e_class1   1\n## 2 0.6742386 0.0021502138 positive 0.6742386 #48A4F0 e_class1   1\n## 3 0.7378741 0.0004730567 positive 0.7378741 #48A4F0 e_class1   1\n## 4 0.6236449 0.0056818984 positive 0.6236449 #48A4F0 e_class1   1\n## 5 0.6045747 0.0078660171 positive 0.6045747 #48A4F0 e_class1   1\nAnd we can see, some attributes have been set when we build the network like v_group, these are internal attributes of metanet and are related to the following analysis and visualization.\nWe will talk about how to set these attributes for some specific analysis later.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulation</span>"
    ]
  },
  {
    "objectID": "03-manipulation.html#attributes",
    "href": "03-manipulation.html#attributes",
    "title": "\n3  Manipulation\n",
    "section": "",
    "text": "Table 3.1: Internal attributes of a metanet\n\n\n\n\n\n\n\nAttribute name\nDescription\n\n\n\nv_group\nthe big group for network, usually one omics data produces one group. Related to the vertex shape.\n\n\nv_class\nsome annotation of vertex, maybe classification or network modules. Related to the vertex color.\n\n\nsize\nnumeric variable assign to the vertex size.\n\n\ne_type\nthe type of edges, often be the positive or negative according to correlation. Related to the edge color.\n\n\nwidth\nnumeric variable assign to the edge width.\n\n\ne_class\nthe second type of edges, often be the intra or inter according to two vertex group. Related to the edge line type.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulation</span>"
    ]
  },
  {
    "objectID": "03-manipulation.html#annotation",
    "href": "03-manipulation.html#annotation",
    "title": "\n3  Manipulation\n",
    "section": "\n3.2 Annotation",
    "text": "3.2 Annotation\nSometimes we have lots of annotation tables need to add to the network, such as abundance table, taxonomy table and so on, we can use c_net_annotate() to do this.\nThe annotation dataframe needs have rowname or a “name” column which match the vertex name of metanet, c_net_annotate(mode = \"v\") or anno_vertex() will automatically match the vertex name and combine the table.\n\nc_net_annotate(co_net, taxonomy[\"Phylum\"], mode = \"v\") -&gt; co_net1\nget_v(co_net1) %&gt;% head(5)\n##                           name  v_group  v_class size\n## 1 s__un_f__Thermomonosporaceae v_group1 v_class1    4\n## 2        s__Pelomonas_puraquae v_group1 v_class1    4\n## 3     s__Rhizobacter_bergeniae v_group1 v_class1    4\n## 4     s__Flavobacterium_terrae v_group1 v_class1    4\n## 5         s__un_g__Rhizobacter v_group1 v_class1    4\n##                          label  shape   color            Phylum\n## 1 s__un_f__Thermomonosporaceae circle #a6bce3 p__Actinobacteria\n## 2        s__Pelomonas_puraquae circle #a6bce3 p__Proteobacteria\n## 3     s__Rhizobacter_bergeniae circle #a6bce3 p__Proteobacteria\n## 4     s__Flavobacterium_terrae circle #a6bce3  p__Bacteroidetes\n## 5         s__un_g__Rhizobacter circle #a6bce3 p__Proteobacteria\n\nc_net_annotate(mode = \"e\") or anno_edge() receives the same format annotation dataframe, it will automatically match the “from” and “to” columns so that you can summary the links.\n\nanno &lt;- data.frame(\"from\" = \"s__un_f__Thermomonosporaceae\", \"to\" = \"s__Actinocorallia_herbida\", new_atr = \"new\")\nc_net_annotate(co_net, anno, mode = \"e\") -&gt; co_net1\nget_e(co_net1) %&gt;% head(5)\n##   id                         from                            to    weight\n## 1  1 s__un_f__Thermomonosporaceae     s__Actinocorallia_herbida 0.6759546\n## 2  2 s__un_f__Thermomonosporaceae       s__Kribbella_catacumbae 0.6742386\n## 3  3 s__un_f__Thermomonosporaceae       s__Kineosporia_rhamnosa 0.7378741\n## 4  4 s__un_f__Thermomonosporaceae   s__un_f__Micromonosporaceae 0.6236449\n## 5  5 s__un_f__Thermomonosporaceae s__Flavobacterium_saliperosum 0.6045747\n##         cor      p.value   e_type     width   color  e_class lty new_atr\n## 1 0.6759546 0.0020739524 positive 0.6759546 #48A4F0 e_class1   1     new\n## 2 0.6742386 0.0021502138 positive 0.6742386 #48A4F0 e_class1   1    &lt;NA&gt;\n## 3 0.7378741 0.0004730567 positive 0.7378741 #48A4F0 e_class1   1    &lt;NA&gt;\n## 4 0.6236449 0.0056818984 positive 0.6236449 #48A4F0 e_class1   1    &lt;NA&gt;\n## 5 0.6045747 0.0078660171 positive 0.6045747 #48A4F0 e_class1   1    &lt;NA&gt;\n\nMetaNet provides function c_net_set() for easily annotation when you have more than one annotation table (it’s normal when you do a multi-omics analysis).\n\nAbundance_df &lt;- data.frame(\"Abundance\" = colSums(totu))\n# two annotation tables for vertex at same time, the rownames of Abundance_df and taxonomy do not need to be the same.\nco_net1 &lt;- c_net_set(co_net, taxonomy[\"Phylum\"], Abundance_df)\n\nget_v(co_net1) %&gt;% head(5)\n##                           name  v_group  v_class size\n## 1 s__un_f__Thermomonosporaceae v_group1 v_class1    4\n## 2        s__Pelomonas_puraquae v_group1 v_class1    4\n## 3     s__Rhizobacter_bergeniae v_group1 v_class1    4\n## 4     s__Flavobacterium_terrae v_group1 v_class1    4\n## 5         s__un_g__Rhizobacter v_group1 v_class1    4\n##                          label  shape   color            Phylum Abundance\n## 1 s__un_f__Thermomonosporaceae circle #a6bce3 p__Actinobacteria     26147\n## 2        s__Pelomonas_puraquae circle #a6bce3 p__Proteobacteria     25217\n## 3     s__Rhizobacter_bergeniae circle #a6bce3 p__Proteobacteria     16592\n## 4     s__Flavobacterium_terrae circle #a6bce3  p__Bacteroidetes     16484\n## 5         s__un_g__Rhizobacter circle #a6bce3 p__Proteobacteria     13895\n\n\n\n\n\n\n\nNote\n\n\n\nIf you have a vector and you absolutely know it matches the vertex name of network, you can use igraph method to annotate (Don’t recommend), same as the edge annotate vector. Refer to the igraph manual for more details.\n\n\n\nco_net1 &lt;- co_net\n\n# add vertex attribute\nV(co_net1)$new_attri &lt;- seq_len(length(co_net1))\nget_v(co_net1) %&gt;% head(5)\n##                           name  v_group  v_class size\n## 1 s__un_f__Thermomonosporaceae v_group1 v_class1    4\n## 2        s__Pelomonas_puraquae v_group1 v_class1    4\n## 3     s__Rhizobacter_bergeniae v_group1 v_class1    4\n## 4     s__Flavobacterium_terrae v_group1 v_class1    4\n## 5         s__un_g__Rhizobacter v_group1 v_class1    4\n##                          label  shape   color new_attri\n## 1 s__un_f__Thermomonosporaceae circle #a6bce3         1\n## 2        s__Pelomonas_puraquae circle #a6bce3         2\n## 3     s__Rhizobacter_bergeniae circle #a6bce3         3\n## 4     s__Flavobacterium_terrae circle #a6bce3         4\n## 5         s__un_g__Rhizobacter circle #a6bce3         5\n\n# add edge attribute\nE(co_net1)$new_attri &lt;- \"new attribute\"\nget_e(co_net1) %&gt;% head(5)\n##   id                         from                            to    weight\n## 1  1 s__un_f__Thermomonosporaceae     s__Actinocorallia_herbida 0.6759546\n## 2  2 s__un_f__Thermomonosporaceae       s__Kribbella_catacumbae 0.6742386\n## 3  3 s__un_f__Thermomonosporaceae       s__Kineosporia_rhamnosa 0.7378741\n## 4  4 s__un_f__Thermomonosporaceae   s__un_f__Micromonosporaceae 0.6236449\n## 5  5 s__un_f__Thermomonosporaceae s__Flavobacterium_saliperosum 0.6045747\n##         cor      p.value   e_type     width   color  e_class lty     new_attri\n## 1 0.6759546 0.0020739524 positive 0.6759546 #48A4F0 e_class1   1 new attribute\n## 2 0.6742386 0.0021502138 positive 0.6742386 #48A4F0 e_class1   1 new attribute\n## 3 0.7378741 0.0004730567 positive 0.7378741 #48A4F0 e_class1   1 new attribute\n## 4 0.6236449 0.0056818984 positive 0.6236449 #48A4F0 e_class1   1 new attribute\n## 5 0.6045747 0.0078660171 positive 0.6045747 #48A4F0 e_class1   1 new attribute",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulation</span>"
    ]
  },
  {
    "objectID": "03-manipulation.html#set-attributes",
    "href": "03-manipulation.html#set-attributes",
    "title": "\n3  Manipulation\n",
    "section": "\n3.3 Set attributes",
    "text": "3.3 Set attributes\nAs we mentioned before, there are some internal attributes have been set when building network, which are related to the network visualization (Table 3.1). So we can use c_net_set() to custom these attributes fitting to our research needs.\nGive the network various annotate tables and determine which columns use to set, we can give the columns name (one or more) to vertex_group, vertex_class, vertex_size, edge_type, edge_class, edge_width.\nAnd the colors, linetypes, shapes and legends will be assigned automatically, just use plot() to get the basic metanet figure. For more details to customize the plot, refer to the next section: Chapter 4.\ndata(\"multi_test\", package = \"MetaNet\")\ndata(\"c_net\", package = \"MetaNet\")\n# build a multi-network\nmulti1 &lt;- multi_net_build(list(Microbiome = micro, Metabolome = metab, Transcriptome = transc))\n\nplot(multi1)\n\n# set vertex_class\nmulti1_with_anno &lt;- c_net_set(multi1, micro_g, metab_g, transc_g, vertex_class = c(\"Phylum\", \"kingdom\", \"type\"))\n# set vertex_size\nmulti1_with_anno &lt;- c_net_set(multi1_with_anno,\n  data.frame(\"Abundance1\" = colSums(micro)),\n  data.frame(\"Abundance2\" = colSums(metab)),\n  data.frame(\"Abundance3\" = colSums(transc)),\n  vertex_size = paste0(\"Abundance\", 1:3)\n)\n\nplot(multi1_with_anno)\n\n\n\n\n\n\n\n\n\n(a) Without annotation\n\n\n\n\n\n\n\n\n\n(b) With annotation\n\n\n\n\n\n\nFigure 3.1: Basic network plot",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulation</span>"
    ]
  },
  {
    "objectID": "03-manipulation.html#filter-sub-net",
    "href": "03-manipulation.html#filter-sub-net",
    "title": "\n3  Manipulation\n",
    "section": "\n3.4 Filter (Sub-net)",
    "text": "3.4 Filter (Sub-net)\nAfter setting your network properly, you may need to analysis part of the whole network (especially in the multi-omics analysis), c_net_filter() can get the sub-net conveniently, you can put lots of filter conditions (like the dplyr::filter) and get the sub-net you want.\n\ndata(\"multi_net\", package = \"MetaNet\")\nmulti2 &lt;- c_net_filter(multi1_with_anno, v_group %in% c(\"Microbiome\", \"Metabolome\")) %&gt;%\n  c_net_filter(., e_class == \"intra\", mode = \"e\")\n\npar(mfrow = c(2, 1))\nplot(multi1_with_anno, lty_legend = T, main = \"Before filtering network\") # before filter\nplot(multi2, lty_legend = T, main = \"After filtering network\") # after filter\n\n\n\n\n\n\nFigure 3.2: Filter network",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulation</span>"
    ]
  },
  {
    "objectID": "03-manipulation.html#union-combine",
    "href": "03-manipulation.html#union-combine",
    "title": "\n3  Manipulation\n",
    "section": "\n3.5 Union (Combine)",
    "text": "3.5 Union (Combine)\nIf you have two networks and want to combine them, you can use c_net_union().\n\ndata(\"c_net\")\nplot(co_net)\nplot(co_net2)\n\nco_net_union &lt;- c_net_union(co_net, co_net2)\nplot(co_net_union)\n\n\n\n\n\n\n\n\n\n(a) network 1\n\n\n\n\n\n\n\n\n\n(b) network 2\n\n\n\n\n\n\n\n\n\n\n\n(c) union network\n\n\n\n\n\n\nFigure 3.3: Union network",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulation</span>"
    ]
  },
  {
    "objectID": "03-manipulation.html#skeleton",
    "href": "03-manipulation.html#skeleton",
    "title": "\n3  Manipulation\n",
    "section": "\n3.6 Skeleton",
    "text": "3.6 Skeleton\nIf you want to summary the edges source and target according to one group, summ_2col is a easy way to get this information.\ndirect = F argument means this is a undirected relationship, so “a-b” and “b-a” will summary to one type edge.\n\nc_net_annotate(co_net, select(taxonomy, \"Phylum\"), mode = \"e\") -&gt; co_net1\ndf &lt;- get_e(co_net1)[, c(\"Phylum_from\", \"Phylum_to\")]\nsumm_2col(df, direct = F) %&gt;% arrange(-count) -&gt; Phylum_from_to\n\n\nkbl(Phylum_from_to, caption = \"Summary of edges according to Phylum\") %&gt;%\n  kable_paper() %&gt;%\n  scroll_box(width = \"100%\", height = \"400px\")\n\n\n\nSummary of edges according to Phylum\n\nPhylum_from\nPhylum_to\ncount\n\n\n\np__Proteobacteria\np__Proteobacteria\n210\n\n\np__Actinobacteria\np__Proteobacteria\n161\n\n\np__Firmicutes\np__Proteobacteria\n63\n\n\np__Actinobacteria\np__Actinobacteria\n62\n\n\np__Bacteroidetes\np__Proteobacteria\n54\n\n\np__Actinobacteria\np__Firmicutes\n34\n\n\np__Actinobacteria\np__Bacteroidetes\n25\n\n\np__Acidobacteria\np__Proteobacteria\n21\n\n\np__Proteobacteria\np__Verrucomicrobia\n13\n\n\np__Bacteroidetes\np__Firmicutes\n11\n\n\np__Firmicutes\np__Firmicutes\n10\n\n\np__Chloroflexi\np__Proteobacteria\n9\n\n\np__Actinobacteria\np__Chloroflexi\n8\n\n\np__Planctomycetes\np__Proteobacteria\n7\n\n\np__Acidobacteria\np__Actinobacteria\n6\n\n\np__Actinobacteria\np__Verrucomicrobia\n5\n\n\np__Bacteroidetes\np__Bacteroidetes\n5\n\n\np__Chlamydiae\np__Proteobacteria\n5\n\n\np__Chloroflexi\np__Firmicutes\n5\n\n\np__Bacteroidetes\np__Verrucomicrobia\n4\n\n\np__Actinobacteria\np__Planctomycetes\n3\n\n\np__Proteobacteria\np__Spirochaetes\n3\n\n\np__Acidobacteria\np__Chloroflexi\n2\n\n\np__Actinobacteria\np__Chlamydiae\n2\n\n\np__Actinobacteria\np__Spirochaetes\n2\n\n\np__Chloroflexi\np__Verrucomicrobia\n2\n\n\np__Acidobacteria\np__Firmicutes\n1\n\n\np__Acidobacteria\np__Verrucomicrobia\n1\n\n\np__Bacteroidetes\np__Chloroflexi\n1\n\n\np__Bacteroidetes\np__Spirochaetes\n1\n\n\np__Chlamydiae\np__Firmicutes\n1\n\n\np__Chlamydiae\np__Spirochaetes\n1\n\n\np__Firmicutes\np__Planctomycetes\n1\n\n\np__Firmicutes\np__Verrucomicrobia\n1\n\n\n\n\n\n\n\nThen you can use sankey plot to display the links.\n\npcutils::my_sankey(Phylum_from_to, dragY = T, fontSize = 10, width = 600, numberFormat = \",.4\")\n\n\n\n\n\n\nFigure 3.4: Sankey plot display edges according to Phylum\n\n\n\nOr use the circlize plot to display. link_stat() have more arguments than summ_2col() for summary edges.\n\nc_net_set(co_net, select(taxonomy, \"Phylum\")) -&gt; co_net1\nlinks_stat(co_net1, topN = 5, group = \"Phylum\", e_type = \"all\")\n\n\n\n\n\n\nFigure 3.5: Circlize plot display edges according to Phylum\n\n\n\n\nOther important action for a network is extracting the skeleton according to one group, which I call get skeleton plot. get_group_skeleton() can annotate all nodes with a group then combine each group nodes as a big node, and calculate new links between all groups.\nThis plot shows the flows between different groups clearly. By the way, the result will display by different edge types, if you just want summary all edges, set the e_type as one same character (use c_net_set()).\n\nget_group_skeleton(co_net1, Group = \"Phylum\") -&gt; ske_net\nplot(ske_net, vertex.label = NA)\n\n\n\n\n\n\nFigure 3.6: Skeleton plot according to the Phylum\n\n\n\n\n\n\n\n\n\nFigure 3.7: Skeleton plot according to the Phylum",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulation</span>"
    ]
  },
  {
    "objectID": "03-manipulation.html#save",
    "href": "03-manipulation.html#save",
    "title": "\n3  Manipulation\n",
    "section": "\n3.7 Save",
    "text": "3.7 Save\nMetaNet also support to export various format network files (data.frame, graphml, pajek, lgl, …) for following analysis in other softwares (Cytoscape, Gephi…). You can use c_net_save() to save the network as a file, and use c_net_load() to load the network from a file.\n\nc_net_save(co_net, filename = \"My_net\", format = \"data.frame\")\nc_net_save(co_net, filename = \"My_net\", format = \"graphml\")\n\nc_net_load(\"My_net.graphml\")",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulation</span>"
    ]
  },
  {
    "objectID": "04-visualization.html",
    "href": "04-visualization.html",
    "title": "4  Visualization",
    "section": "",
    "text": "4.1 Basic plot",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Visualization</span>"
    ]
  },
  {
    "objectID": "04-visualization.html#basic-plot",
    "href": "04-visualization.html#basic-plot",
    "title": "4  Visualization",
    "section": "",
    "text": "Set attributes\nAs we mentioned before, there are some internal attributes have been set when building network, which are related to the network visualization (Table 3.1). So we can use c_net_set() to custom these attributes fitting to our research needs.\nGive the network various annotate tables and determine which columns use to set, we can give the columns name (one or more) to vertex_group, vertex_class, vertex_size, edge_type, edge_class, edge_width.\nAnd the colors, linetypes, shapes and legends will be assigned automatically, just use plot() to get the basic metanet figure. For more details to customize the plot, refer to Table 4.1.\n\ndata(\"multi_test\", package = \"MetaNet\")\ndata(\"c_net\", package = \"MetaNet\")\n# build a multi-network\nmulti1 &lt;- multi_net_build(list(Microbiome = micro, Metabolome = metab, Transcriptome = transc))\n# v_group is default, three different table\n\nplot(multi1)\n\n# set vertex_class\nmulti1_with_anno &lt;- c_net_set(multi1, micro_g, metab_g, transc_g, vertex_class = c(\"Phylum\", \"kingdom\", \"type\"))\n# set vertex_size\nmulti1_with_anno &lt;- c_net_set(multi1_with_anno,\n  data.frame(\"Abundance1\" = colSums(micro)),\n  data.frame(\"Abundance2\" = colSums(metab)),\n  data.frame(\"Abundance3\" = colSums(transc)),\n  vertex_size = paste0(\"Abundance\", 1:3)\n)\n\nplot(multi1_with_anno)\n\n\n\n\n\n\n\nFigure 4.1: Basic network plot\n\n\n\n\n\n\n\n\n\n\n\nFigure 4.2: Basic network plot\n\n\n\n\n\n\n\nPlot setting\nIf you want to custom the network plot flexibility, use the c_net_plot() which contains many flexible arguments. The arguments of c_net_plot() are listed below:\n\n\n\n\nTable 4.1: Description of c_net_plot() arguments.\n\n\n\n\n\n\n\nArguments\nDescription\n\n\n\n\ncoors\n1. cooridnates dataframe, 2. layout function (e.g. as_star(), as_tree(), in_circle(), nicely()... see help(c_net_lay))\n\n\nvertex.color\ncolor of nodes, receive vector (1. length same to number of nodes; 2. length same to numbers of v_class; 3. named verctor like c(A=\"red\",B=\"blue\"))\n\n\nvertex. shape\nshape of nodes, receive vector (1. length same to number of nodes; 2. length same to numbers of v_group; 3. named verctor like c(v_group1=\"circle\",B=\"square\"))shape list: none, circle, square, csquare, rectangle, crectangle, vrectangle, pie, raster, or sphere\n\n\nvertex.size\nsize of nodes, receive numerical vector (length same to number of nodes)please use mmscale to control vertex.size, don't be too large.\n\n\nvertex_size_range\nthe vertex size range, e.g. c(1,10)\n\n\nlabels_num\nshow how many labels,&gt;1 indicates number,\n\n\nvertex.label\nthe label of nodes, NA indicates no label\n\n\nvertex.label.family\nlabel font family\n\n\nvertex.label.font\nlabel font, 1 plain, 2 bold, 3 italic, 4 bold italic, 5 symbol\n\n\nvertex.label.cex\nlabel size\n\n\nvertex.label.dist\ndistance from label to nodes\n\n\nvertex.label.color\nThe color of the labels, The default value is black.\n\n\nvertex.label.degree\n0:right, pi: left, pi/2:below, -pi/2:above\n\n\nvertex.frame.color\ncolor of nodes frame\n\n\nplot_module\nuse module as the v_class\n\n\nmark_module\nlogical, mark the modules?\n\n\nmark_color\nmark color\n\n\nmark_alpha\nmark fill alpha, default 0.3\n\n\nmodule_label\nshow module label?\n\n\nmodule_label_cex\nmodule label cex\n\n\nmodule_label_color\nmodule label color\n\n\nmodule_label_just\nmodule label just, default c(0.5,0.5)\n\n\nedge.color\ncolor of edges, receive vector (1. length same to number of edges; 2. length same to numbers of e_type; 3. named verctor like c(A=\"red\",B=\"blue\"))\n\n\nedge.width\nwidth of edge, receive numerical vector (length same to number of edges)please use mmscale to control vertex.size, don't be too large.\n\n\nedge_width_range\nthe edge width range, e.g. c(1,10)\n\n\nedge.lty\nlinetype of edge, receive vector (1. length same to number of edges; 2. length same to numbers of e_class; 3. named verctor like c(A=\"red\",B=\"blue\"))\n\n\nedge.arrow.size\narrow size for directed network\n\n\nedge.arrow.width\narrow width for directed network\n\n\narrow.mode\narrow mode, 0 no arrow, 1 back, 2 forward, 3 both\n\n\nedge.label\nthe label of edges, NA indicates no label\n\n\nedge.label.family\nlabel font family\n\n\nedge.label.font\nlabel font, 1 plain, 2 bold, 3 italic, 4 bold italic, 5 symbol\n\n\nedge.label.cex\nlabel size\n\n\nedge.label.x\nlabel x-axis\n\n\nedge.label.y\nlabel y-axis\n\n\nedge.label.color\nlabel color\n\n\nedge.curved\nThe curvature of the body, on a scale of 0-1, FALSE means 0, TRUE means 0.5\n\n\nlegend\nshow any legend? FALSE means close all legends\n\n\nlegend_cex\ncharacter expansion factor relative to current par('cex'), default: 1\n\n\nlegend_position\nlegend_position, default: c(left_leg_x=-1.9,left_leg_y=1,right_leg_x=1.2,right_leg_y=1)\n\n\nlegend_number\nadd numbers in legend? (v_class number, e_type number...)\n\n\nlty_legend, lty_legend_title, lty_legend_order\nshow lty_legend? and the title, the oreder of legend receives a vector\n\n\nsize_legend, size_legend_tiltle\nshow size_legend? and the title\n\n\nedge_legend, edge_legend_title, edge_legend_order\nshow edge_legend? and the title, the order of legend receives a vector\n\n\nwidth_legend, width_legend_title\nshow width_legend? and the title\n\n\ncolor_legend, color_legend_order\nshow col_legend? and the title, the order of legend receives a vector\n\n\ngroup_legend_title, group_legend_order\nthe title of group, the order of legend receives a vector\n\n\nmargin\nmargin, a vector whose length =4\n\n\nrescale\nscale the coors to [-1,1], default F\n\n\nasp\ny/x ratio\n\n\nframe\nif T, add frame\n\n\nmain\nthe main title of graph\n\n\nsub\nsubtitle\n\n\nxlab\nx-axis label\n\n\nylab\ny-axis label\n\n\nseed\nrandom seed, default:1234, make sure each plot is the same\n\n\nparams_list\na list of parameters, e.g. list(edge_legend = TRUE, lty_legend = FALSE), when the parameter is duplicated, the format argument will be used rather than the argument in params_list\n\n\n\n\n\n\n\n\n\n\nFor example, we can use c_net_plot() to plot the network with annotation and set the color, size, width, legend, etc.\n\nc_net_plot(multi1_with_anno,\n  labels_num = 5, vertex.color = get_cols(11, \"col1\"), vertex_size_range = c(3, 10), vertex.label.color = \"red\",\n  edge_width_range = c(0.5, 3), edge.color = c(\"orange\", \"green4\"), edge.curved = 0.2,\n  legend = T, legend_number = T, group_legend_order = c(\"Microbiome\", \"Metabolome\", \"Transcriptome\"),\n  group_legend_title = c(\"Phylum\", \"Metabolome\", \"Transcriptome\"),\n  edge_legend_title = \"Correlation\", edge_legend_order = c(\"positive\", \"negative\"),\n  size_legend = T, size_legend_title = \"Abundance\",\n  width_legend = T, width_legend_title = \"abs(r)\",\n  lty_legend = T, lty_legend_title = \"Omics relationship\"\n)\n\n\n\n\n\n\n\nFigure 4.3: Custom network plot\n\n\n\n\n\nparams_list is a special argument in c_net_plot(), it is a list contains parameters, it is very convenient to use it to plot a series of network with same attributes.\n\nnode_colors &lt;- setNames(get_cols(9, \"col1\"), unique(V(multi1_with_anno)$v_class))\n\nparams_list &lt;- list(\n  coors=c_net_layout(multi1_with_anno),\n  labels_num = 5,\n  vertex.color = node_colors, vertex_size_range = c(3, 10), vertex.label.color = \"red\",\n  edge_width_range = c(0.5, 3), edge.color = c(\"orange\", \"green4\"), edge.curved = 0.2,\n  legend = T, legend_number = T, group_legend_order = c(\"Microbiome\", \"Metabolome\", \"Transcriptome\"),\n  group_legend_title = c(\"Phylum\", \"Metabolome\", \"Transcriptome\"),\n  edge_legend_title = \"Correlation\", edge_legend_order = c(\"positive\", \"negative\"),\n  size_legend = T, size_legend_title = \"Abundance\",\n  width_legend = T, width_legend_title = \"abs(r)\",\n  lty_legend = T, lty_legend_title = \"Omics relationship\"\n)\n\nc_net_plot(multi1_with_anno, params_list = params_list)\n\n# build another multi-network\nmulti1_with_anno2 &lt;- c_net_filter(multi1_with_anno, v_group %in% c(\"Microbiome\", \"Metabolome\")) %&gt;%\n  c_net_filter(., e_class == \"intra\", mode = \"e\")\nc_net_plot(multi1_with_anno2, params_list = params_list)\n\n\n\n\n\n\n\n\n\n\n\n(a) plot1\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) plot2\n\n\n\n\n\n\n\nFigure 4.4: Plot a series of network using params_list",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Visualization</span>"
    ]
  },
  {
    "objectID": "04-visualization.html#layout",
    "href": "04-visualization.html#layout",
    "title": "4  Visualization",
    "section": "4.2 Layout",
    "text": "4.2 Layout\nLayout is an important part of network visualization, a good layout will present information clearly.\nSo, in MetaNet, we always use a coors object to store the coordinates of a layout.\nThe coors is a three-columns data.frame contains “name”, “X”, “Y”. attributes(coors)$curved is a three-columns data.frame contains “from”, “to”, “curved” or NULL.\n\nBasic layout\nUse c_net_layout() to get coordinates with specific layout methods.\n\nc_net_layout(co_net2, method = in_circle()) -&gt; coors\nc_net_plot(co_net2, coors)\n\n\n\n\n\n\n\nFigure 4.5: Plot a network using c_net_layout\n\n\n\n\n\nThe method can be one of\n\nas_line(), as_arc(), as_polygon(), as_polyarc(), as_polycircle(), as_circle_tree(), as_multi_layer(), as_poly_sector().\nlayouts in igraph: in_circle(), nicely(), on_grid(), on_sphere(), randomly(), with_dh(), with_fr(), with_gem(), with_graphopt(), with_kk(), with_lgl(), with_mds(), see igraph::layout_().\nlayouts in ggraph: a character, “auto”, “backbone”, “centrality”, “circlepack”, “dendrogram”, “eigen”, “focus”, “hive”, “igraph”, “linear”, “manual”, “matrix”, “partition”, “pmds”, “stress”, “treemap”, “unrooted”. see ggraph::create_layout().\n\n\n\nCode\ngo &lt;- erdos.renyi.game(30, 0.25)\n# get a metanet\ngo &lt;- c_net_update(go)\n\nlayout_methods &lt;- list(\n  as_star(), as_tree(), in_circle(), nicely(),\n  on_grid(), on_sphere(), randomly(), with_dh(),\n  with_fr(), with_gem(), with_graphopt(), with_kk(),\n  with_lgl(), with_mds(), as_line(), as_arc(),\n  as_polygon(), as_polyarc(), as_polycircle(3), as_circle_tree(),\n  as_multi_layer(2), as_poly_sector()\n)\nnames(layout_methods) &lt;- c(\n  \"as_star \", \"as_tree \", \"in_circle \", \"nicely \",\n  \"on_grid \", \"on_sphere \", \"randomly \", \"with_dh \",\n  \"with_fr \", \"with_gem \", \"with_graphopt \", \"with_kk \",\n  \"with_lgl \", \"with_mds\", \"as_line\", \"as_arc\",\n  \"as_polygon\", \"as_polyarc\", \"as_polycircle\", \"as_circle_tree\",\n  \"as_multi_layer\", \"as_poly_sector\"\n)\n\npar(mfrow = c(6, 4))\nfor (i in names(layout_methods)) {\n  plot(go, layout_methods[[i]], legend = F, main = i, labels_num = 0)\n}\n\n\n\n\n\n\n\n\nFigure 4.6: Layout methods for c_net_layout()\n\n\n\n\n\nAnd for each method, you can add some arguments in it:\n\n# get a metanet\ngo &lt;- erdos.renyi.game(30, 0.25)\ngo &lt;- c_net_update(go)\n\nplot(go, coors = with_fr())\nplot(go, coors = with_fr(niter = 99, grid = \"nogrid\"))\n\nThe as_polygon() is interesting: it can draw a network in a polygon shape, and you can change the edge numbers of the polygon.\n\n\n\n\n\n\n\n\nFigure 4.7: Layout of as_polygon() in c_net_layout\n\n\n\n\n\n\n\nTransform layout\nUsing transform_comors can transform layouts, including zooming in and out, X/Y ratio, rotation angle, mirroring, pseudo 3D effects, etc.:\n\n\n\n\n\n\n\n\nFigure 4.8: Simple usage of transform_coors()\n\n\n\n\n\n\n\nGroup layout\nBeside the c_net_layout(), we provide an advanced layout method for a network with group variable: g_layout(). It is easy to use g_layout() to control each group position and layout of each group.\n\n\n\n\n\n\nNote\n\n\n\ng_layout() is a very useful function to layout a network with group variable when we have a multi-omics network (Chapter 7) or module network (Section 5.4).\n\n\n\nFirst, assign a group variable.\nGive a layout1 for group position, one of 1.a dataframe or matrix: rowname is group, two columns are X and Y 2.function: layout method for c_net_layout() default: in_circle()\nAdjust the zoom1 of layout1.\nGive a layout2 (layout method for c_net_layout()) for each group layout, or use a list contains functions match each group.\nAdjust the zoom2 of layout2, you can use a vector to adjust each group zoom.\nuse show_big_layout = T to see the layout1 distribution.\n\n\npar(mfrow = c(2, 1))\n# set circle layout for each group\ng_layout(multi1_with_anno,\n  group = \"v_group\", layout1 = in_circle(),\n  zoom1 = 10, layout2 = in_circle(), zoom2 = 5\n) -&gt; g_coors\nplot(multi1_with_anno, coors = g_coors)\n# set different layout for each group\ng_layout(multi1_with_anno,\n  group = \"v_group\", layout1 = in_circle(), zoom1 = 10,\n  layout2 = list(in_circle(), with_fr(), as_polygon()), zoom2 = 3:5\n) -&gt; g_coors\nplot(multi1_with_anno, coors = g_coors)\n\n\n\n\n\n\n\nFigure 4.9: Simple usage of g_layout()\n\n\n\n\n\nAs layout1 also receive a matrix or data.frame, so we can use the group skeleton of network to adjust the layout1.\n\ndata(\"c_net\", package = \"MetaNet\")\ng_layout(co_net,\n  group = \"v_class\", layout1 = in_circle(), zoom1 = 10,\n  layout2 = in_circle(), zoom2 = c(1, 5, 2, 1, 3, 7)\n) -&gt; g_coors\nplot(co_net, coors = g_coors)\n\n# firstly get the skeleton plot\nget_group_skeleton(co_net, \"v_class\") %&gt;% clean_igraph() -&gt; s_net\n\n# then use tkplot to do manual adjustment.\nx &lt;- igraph::tkplot(s_net)\n# Here: Move nodes within the tkplot window to a layout you like!\nda &lt;- igraph::tkplot.getcoords(x)\n# close the window\nigraph::tkplot.close(x)\n# pass the `da` to layout1\ng_layout(co_net,\n  group = \"v_class\", layout1 = da, zoom1 = 20,\n  layout2 = in_circle(), zoom2 = c(1, 4, 2, 1, 3, 5)\n) -&gt; g_coors\nplot(co_net, coors = g_coors)\n\n\n\n\n\n\n\n\n\nFigure 4.10: Use tkplot to adjust big layout.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4.11: Use tkplot to adjust big layout.\n\n\n\n\n\ng_layout() provides a high degree of customization, you can adjust the layout according to different needs.\nBesides, there are also some good default group layout methods: - g_layout_circlepack() - g_layout_treemap() - g_layout_backbone() - g_layout_stress() - g_layout_polyarc() - g_layout_polygon() - g_layout_polycircle() - g_layout_multi_layer() - g_layout_poly_sector()\n\nCode\nE(co_net)$color &lt;- rep(\"grey\", length(E(co_net)))\nplot(co_net,\n  coors = g_layout_circlepack(co_net, group = \"v_class\"),\n  legend = F, labels_num = 0, main = \"g_layout_circlepack\"\n)\n\nplot(co_net,\n  coors = g_layout_treemap(co_net, group = \"v_class\"),\n  legend = F, labels_num = 0, main = \"g_layout_treemap\"\n)\n\nplot(co_net,\n  coors = g_layout_backbone(co_net, group = \"v_class\"),\n  legend = F, labels_num = 0, main = \"g_layout_backbone\"\n)\n\nplot(co_net,\n  coors = g_layout_stress(co_net, group = \"v_class\"),\n  legend = F, labels_num = 0, main = \"g_layout_stress\"\n)\n\nplot(co_net,\n  coors = g_layout_polyarc(co_net, group = \"v_class\"),\n  legend = F, labels_num = 0, main = \"g_layout_polyarc\"\n)\n\nplot(co_net,\n  coors = g_layout_polygon(co_net, group = \"v_class\"),\n  legend = F, labels_num = 0, main = \"g_layout_polygon\"\n)\n\nplot(co_net,\n  coors = g_layout_polycircle(co_net, group = \"v_class\"),\n  legend = F, labels_num = 0, main = \"g_layout_polycircle\"\n)\n\ng1 &lt;- module_net(3)\nplot(g1,\n  coors = g_layout_multi_layer(g1, group = \"v_class\"),\n  legend = F, labels_num = 0, main = \"g_layout_multi_layer\"\n)\n\nplot(g1,\n  coors = g_layout_multi_layer(g1, group = \"v_class\", layout = on_grid()),\n  legend = F, labels_num = 0, main = \"g_layout_multi_layer\"\n)\n\ng2 &lt;- module_net(5)\nplot(g2,\n  coors = g_layout_poly_sector(g2, group = \"v_class\"),\n  legend = F, labels_num = 0, main = \"g_layout_poly_sector\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n(a) g_layout_circlepack()\n\n\n\n\n\n\n\n\n\n\n\n(b) g_layout_treemap()\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) g_layout_backbone()\n\n\n\n\n\n\n\n\n\n\n\n(d) g_layout_stress()\n\n\n\n\n\n\n\n\n\n\n\n\n\n(e) g_layout_polyarc()\n\n\n\n\n\n\n\n\n\n\n\n(f) g_layout_polygon()\n\n\n\n\n\n\n\n\n\n\n\n\n\n(g) g_layout_polycircle()\n\n\n\n\n\n\n\n\n\n\n\n(h) g_layout_multi_layer()\n\n\n\n\n\n\n\n\n\n\n\n\n\n(i) g_layout_multi_layer(layout = on_grid())\n\n\n\n\n\n\n\n\n\n\n\n(j) g_layout_poly_sector()\n\n\n\n\n\n\n\nFigure 4.12: Usage of g_layout_*()\n\n\n\n\n\n\nspatstat layout\nYou can also use spatstat to construct any polygon, and then randomly or uniformly sample the interior or edges of the polygon to generate a layout:\nif(!require(\"spatstat\"))install.packages(\"spatstat\")\n\npoly_x &lt;- c(0, 2, 2, 0)\npoly_y &lt;- c(0, 0, 1, 1)\nwin_poly &lt;- spatstat.geom::owin(poly = list(x = poly_x, y = poly_y))\nplot(win_poly)\ncoors1 &lt;- spatstat_layout(co_net, win_poly, type = \"random\", mode = \"surface\")\nplot(co_net, coors = coors1)\ncoors1 &lt;- spatstat_layout(co_net, win_poly, type = \"regular\", mode = \"surface\",order_by=\"v_class\")\nplot(co_net, coors = coors1)\ncoors2 &lt;- spatstat_layout(co_net2, win_poly, type = \"random\", mode = \"boundary\")\nplot(co_net2, coors = coors2)\n\n\n\n\n\n\n\n\n\n\n\n(a) plot owin\n\n\n\n\n\n\n\n\n\n\n\n(b) random-surface\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) regular-surface\n\n\n\n\n\n\n\n\n\n\n\n(d) random-boundary\n\n\n\n\n\n\n\nFigure 4.13: Usage of spatstat_layout\n\n\n\nTry a ⭐️：\n\nlibrary(spatstat.geom)\n\ncreate_star_window &lt;- function(r_outer = 1, r_inner = 0.4, center = c(0, 0)) {\n  # 创建五角星的10个顶点（外、内交替）\n  theta &lt;- seq(0, 2 * pi, length.out = 11)[-11]  # 10个点\n  theta_outer &lt;- theta[seq(1, 10, 2)]\n  theta_inner &lt;- theta[seq(2, 10, 2)]\n\n  x &lt;- c(r_outer * cos(theta_outer),\n         r_inner * cos(theta_inner))\n  y &lt;- c(r_outer * sin(theta_outer),\n         r_inner * sin(theta_inner))\n\n  # 重新排序成首尾相连的路径\n  order_index &lt;- c(1,6,2,7,3,8,4,9,5,10)\n  x &lt;- x[order_index] + center[1]\n  y &lt;- y[order_index] + center[2]\n\n  # 构建 spatstat 的 owin 窗口\n  win &lt;- owin(poly = list(x = x, y = y))\n  return(win)\n}\n\nwin_star &lt;- create_star_window()\n\nplot(co_net, coors = spatstat_layout(co_net, win_star, order_by=\"v_class\"))\n\n\n\n\n\n\n\nFigure 4.14: Usage of spatstat_layout in a star\n\n\n\n\n\nEven in a map!\nlibrary(sf)\nnc = st_read(system.file(\"shape/nc.shp\", package=\"sf\"))\n## Reading layer `nc' from data source \n##   `/Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/library/sf/shape/nc.shp' \n##   using driver `ESRI Shapefile'\n## Simple feature collection with 100 features and 14 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\n## Geodetic CRS:  NAD27\nplot(nc[5,c(1,15)])\n\nplot(co_net, coors = spatstat_layout(co_net, nc[5,c(1,15)], type = \"regular\", order_by=\"v_class\"))\n\n\n\n\n\n\n\n\n\n\n\n(a) plot map\n\n\n\n\n\n\n\n\n\n\n\n(b) regular-surface\n\n\n\n\n\n\n\nFigure 4.15: Usage of spatstat_layout in a map",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Visualization</span>"
    ]
  },
  {
    "objectID": "04-visualization.html#other-features",
    "href": "04-visualization.html#other-features",
    "title": "4  Visualization",
    "section": "4.3 Other features",
    "text": "4.3 Other features\n\nModule plot\nuse mark_module = T to mark your modules in network, for more details, see Section 5.4:\n\ntest_module_net &lt;- module_net(module_number = 3, n_node_in_module = 30)\nc_net_plot(test_module_net, mark_module = T,module_label = T,module_label_just=c(0.2,0.8))\n\n\n\n\n\n\n\nFigure 4.16: A 3-modules network generated by module_net()\n\n\n\n\n\n\n\nPie node\n\ndata(\"otutab\")\ndata(\"c_net\")\nhebing(otutab, metadata$Group) -&gt; otutab_G\nhead(otutab_G)\n##                                     NS        WS        CS\n## s__un_f__Thermomonosporaceae 1218.3333 1227.3333 1912.1667\n## s__Pelomonas_puraquae        2087.6667  873.5000 1241.6667\n## s__Rhizobacter_bergeniae      819.1667  781.3333 1164.8333\n## s__Flavobacterium_terrae      816.1667  944.6667  986.5000\n## s__un_g__Rhizobacter          821.8333  540.6667  953.3333\n## s__un_o__Burkholderiales      972.6667  327.5000  522.6667\n\nco_net_f=c_net_filter(co_net,name%in%head(rownames(otutab_G),30))\nc_net_plot(co_net_f,pie_value=otutab_G,vertex.shape=c(\"pie\"),\n    pie_legend=T,color_legend=F,vertex_size_range=c(10,15))\n\n\n\n\n\n\n\nFigure 4.17: A network with pie node\n\n\n\n\n\n\n\nVenn plot\n\ndata(otutab, package = \"pcutils\")\ntab &lt;- otutab[400:485, 1:3]\nvenn_net(tab) -&gt; v_net\nplot(v_net)\n\n\n\n\n\n\n\nFigure 4.18: Venn plot in network style\n\n\n\n\n\n\n\nNetwork tree\n\ndata(\"otutab\", package = \"pcutils\")\ncbind(taxonomy, num = rowSums(otutab))[1:20, ] -&gt; test\ndf2net_tree(test) -&gt; ttt\n\npar(mfrow = c(1, 2))\nplot(ttt, edge_legend = F, main = \"Tree network\", legend_position = c(left_leg_x = -1.3),\n  edge.arrow.size = 1,edge.arrow.width = 1,rescale=T)\nplot(ttt, coors = as_circle_tree(), legend = F, main = \"Circle tree network\",\n  edge.arrow.size = 0.5,edge.arrow.width = 1,rescale=T)\n\n\n\n\n\n\n\nFigure 4.19: Dataframe to network tree plot",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Visualization</span>"
    ]
  },
  {
    "objectID": "04-visualization.html#other-styles",
    "href": "04-visualization.html#other-styles",
    "title": "4  Visualization",
    "section": "4.4 Other styles",
    "text": "4.4 Other styles\nIt is also easy to transfer the basic plot to other styles, like ggplot2, Gephi, Cytoscape, and NetworkD3.\n\nggplot2\nIf you are more familiar with ggplot2, use the function as.ggig() transfer the basic R plot to ggplot2 style, so that you can use some convenient function like labs(), theme(), ggsave(), and cowplot::plot_grid() to make better figure.\n\nas.ggig(multi1_with_anno) -&gt; ggig\nplot(ggig)\n\n\n\n\n\n\n\nFigure 4.20: Plot a network in ggplot2 style\n\n\n\n\n\n\n\nGephi\nIf you are dealing with some big dataset, We recommend to use Gephi to make layout. We provide a interface to Gephi by graphml format file, you can use the algorithm in Gephi then export a graphml file.\n\nplot(co_net)\nc_net_save(co_net, filename = \"test\", format = \"graphml\")\n# then input test.graphml to Gephi and do a layout\n\n# and export a graphml file from Gephi: test2.graphml, So you can re-draw it in MetaNet\ninput_gephi(\"test2.graphml\") -&gt; gephi\n\nc_net_plot(co_net, coors = gephi$coors, legend_number = T, group_legend_title = \"Phylum\")\n\n\n\nCytoscape\nCytoscape is also a pretty software for network visualization which contains lots of plugins.\nUse the “data.frame” and “cyjs” format to transfer network.\n\nplot(co_net)\nc_net_save(co_net, filename = \"test\", format = \"data.frame\")\n# then input test_nodes.csv and test_nodes.csv to Cytoscape and do a layout\n\n# and export a cyjs file from Cytoscape: test.cyjs, So you can re-draw it in MetaNet\ninput_cytoscape(\"test.cyjs\") -&gt; cyto\n\nc_net_plot(co_net, coors = cyto$coors, legend_number = T, group_legend_title = \"Phylum\")\n\n\n\nNetworkD3\nNetworkD3 can produce interactive network plot based on JavaScript, the output object is a htmlwidgets which are suitable for website.\n\nnetD3plot(multi1_with_anno)\n\n\n\n\n\n\n\nFigure 4.21: Plot a network in NetworkD3 style",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Visualization</span>"
    ]
  },
  {
    "objectID": "04-visualization.html#intersting-plot",
    "href": "04-visualization.html#intersting-plot",
    "title": "4  Visualization",
    "section": "4.5 Intersting plot",
    "text": "4.5 Intersting plot\n\nTwo columns edge list\n\n\ntwocol &lt;- data.frame(\n  \"col1\" = sample(letters, 30, replace = TRUE),\n  \"col2\" = sample(c(\"A\", \"B\"), 30, replace = TRUE)\n)\ntwocol_net &lt;- twocol_edgelist(twocol)\nc_net_plot(twocol_net, g_layout_polygon(twocol_net))\n\n\n\n\n\n\n\nFigure 4.22: Two columns edge list plot\n\n\n\n\n\n\nOlympic rings plot\n\n\nolympic_rings_net()\n\n\n\n\n\n\n\nFigure 4.23: Olympic rings plot",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Visualization</span>"
    ]
  },
  {
    "objectID": "05-topology.html",
    "href": "05-topology.html",
    "title": "\n5  Topology\n",
    "section": "",
    "text": "5.1 Topological indexes\nThere are lots of topological indexes for network analysis, we collected many indexes often used for biological research.\nThe first part is topological indexes for individual nodes.\nTable 5.1: Topological indexes for individual nodes\n\n\n\n\nIndexes\nFormula\nNote\nDescription\n\n\n\nConnectivity/ Degree (centrality)\n$k_i=\\sum_{j\\neq i}a_{ij}$\n𝑎𝑖𝑗 is the connection strength between nodes i and j. when 𝑎𝑖𝑗=1, ki is the unweighted degree\nIt is also called node degree. It is the most commonly used concept for describing the topological property of a node in a network.\n\n\nBetweenness centrality\n$B_i=\\sum_{j,k}\\frac{\\sigma(i,j,k)}{\\sigma(j,k)}$\n𝜎(𝑗,𝑖,𝑘) is the number of shortest paths between nodes j and k that pass through node i. 𝜎(𝑗,𝑘) is the total number of shortest paths between j and k.\nIt is used to describe the ratio of paths that pass through the ith node. High Betweenness node can serve as a broker similar to stress centrality.\n\n\nCloseness centrality\n$Ci=1/\\sum_{i\\neq j}d_{ij}$\nThe closeness centrality of a vertex is defined as the inverse of the sum of distances to all the other vertices in the graph. dij is the shortest distances from node i to j.\nCloseness centrality measures how many steps is required to access every other vertex from a given vertex.\n\n\nEigenvector centrality\n$EC_i=\\frac{1}{\\lambda}\\sum_{j\\in M(i)}EC_j$\nM(𝑖) is the set of nodes that are connected to the ith node and λ is a constant eigenvalue.\nIt is used to describe the degree of a central node that it is connected to other central nodes.\n\n\nClustering coefficient\n$CCo_i=\\frac{2l_i}{k_i'(k_i'-1)}$\nli is the number of links between neighbors of node i and k i ’ is the number of neighbors of node i.\nIt describe how well a node is connected with its neighbors. If it is fully connected to its neighbors, the clustering coefficient is 1. A value close to 0 means that there are hardly any connections with its neighbors. It was used to describe hierarchical properties of networks.\n\n\nEccentricity\n$E_i=\\max_{j\\neq i}(d_{ij})$\ndij is the shortest distance from node i to node j\nThe eccentricity of a vertex is its shortest path distance from the farthest other node in the graph.\n\n\nPage.rank\n$PR_i=\\sum_{j\\in B_i}\\frac{PR_j}{l_j}$\ni is the node whose pr value needs to be calculated, and Bi is the set of all nodes pointing to node i. PRj is the pr value of node j and lj is the number of links between neighbors of node j.\nCalculates the Google PageRank for the specified vertices. PageRank, or webpage ranking, also known as webpage level, is an indicator to measure the importance of webpages.\n\n\nKleinberg's hub and authority centrality\n$HC=\\lambda_{AA^T}$ $AC=\\lambda_{A^TA}$\nThe hub scores of the vertices are defined as the principal eigenvector of AAT, the authority scores of the vertices are defined as the principal eigenvector of ATA. where A is the adjacency matrix of the graph.\nA node is an authority if it is linked to by hubs; it is a hub if it links to authorities.\nThe second part is the overall network topological indexes.\nTable 5.2: The overall network topological indexes\n\n\n\n\nIndexes\nFormula\nNote\nDescription\n\n\n\nAverage connectivity/ degree\n$\\overline{k}=\\frac{\\sum_{i=1}^{n}k_i}{n}$\nk i is degree of node i and n is the number of nodes.\nHigher avgK means a more complex network.\n\n\nAverage path length/ Average geodesic distance\n$L=\\frac{\\sum_{i \\ne j}d_{ij}}{n(n-1)}$\ndij is the shortest path between node i and j.\nA smaller GD means all the nodes in the network are closer.\n\n\nglobal efficiency/ Geodesic efficiency\n$E_g=\\frac{\\sum_{i \\ne j}1/d_{ij}}{n(n-1)}$\nall parameters shown above.\nIt is the opposite of GD. A higher E means that the nodes are closer.\n\n\nCentralization of degree\n$CD=\\sum_{i=1}^{n}(\\max(k)-k_i)$\nmax(k) is the maximal value of all connectivity values and k i represents the connectivity of ith node. Finally this value is normalized by the theoretical maximum centralization score.\nIt is close to 1 for a network with star topology and in contrast close to 0 for a network where each node has the same connectivity.\n\n\nCentralization of betweenness\n$CB=\\sum_{i=1}^{n}(\\max(B)-B_i)$\nmax(B) is the maximal value of all betweenness values and B i represents the betweenness of ith node. Finally this value is normalized by the theoretical maximum centralization score.\nIt is close to 0 for a network where each node has the same betweenness, and the bigger the more difference among all betweenness values.\n\n\nCentralization of closeness\n$CC=\\sum_{i=1}^{n}(\\max(C)-C_i)$\nmax(C) is the maximal value of all closeness values and Ci represents the closeness of ith node. Finally this value is normalized by the theoretical maximum centralization score.\nIt is close to 0 for a network where each node has the same closeness, and the bigger the more difference among all closeness values.\n\n\nCentralization of eigenvector centrality\n$CE=\\sum_{i=1}^{n}(\\max(EC)-EC_i)$\nmax(EC) is the maximal value of all eigenvector centrality values and EC i represents the eigenvector centrality of ith node. Finally this value is normalized by the theoretical maximum centralization score.\nIt is close to 0 for a network where each node has the same eigenvector centrality, and the bigger the more difference among all eigenvector centrality values.\n\n\nDensity\n$D=\\frac{2l}{n(n-1)}$\nl is the sum of total links.\nThe density of a graph is the ratio of the number of edges and the number of possible edges. It is closely related to the average connectivity.\n\n\nAverage clustering coefficient\n$\\overline{CCo}=\\frac{\\sum_{i=1}^{n}CCo_i}{n}$\n𝐶𝐶oi is the clustering coefficient of node i.\nIt is used to measure the extent of module structure present in a network.\n\n\nTransitivity\n$Tr=\\frac{\\sum_{i=1}^{n}2l_i}{\\sum_{i=1}^{n}(k'_i)(k'_i-1)}$\nli is the number of links between neighbors of node i and k i ’ is the number of neighbors of node i.\nSometimes it is also called the entire clustering coefficient. It has been shown to be a key structural property in social networks.\n\n\nNatural connectivity\n$NC=\\ln{\\left(\\frac{1}{N}\\sum_{i=1}^{N}e^{\\lambda_i}\\right)}$\nWhere N is nodes number of the network, represents the eigenvalue of the network adjacency matrix.\nTopological indexes for edges are less, so we do not list them here.\nWe can get all these indexes easily by using net_par(). you can choose different mode (n,v,e) to get indexes of network, vertexes or edges especially or just use “all” to get a list contains all indexes.\nmake_graph(\"Walther\") %&gt;% net_par(mode = \"all\")\nmake_graph(\"Walther\") %&gt;% net_par(mode = \"n\")\n## $n_index\n##      name Node_number Edge_number Edge_density Negative_percentage\n## 1 Walther          25          31    0.1033333                  NA\n##   Average_path_length Global_efficiency Average_degree Average_weighted_degree\n## 1            3.586667         0.3679762           2.48                    2.48\n##   Diameter Clustering_coefficient Centralized_betweenness Natural_connectivity\n## 1        8                      0               0.1436084             1.029526\n## \n## $v_index\n## NULL\n## \n## $e_index\n## NULL\nOr you can use c_net_index() to calculate topological indexes and store in the network itself, which is very useful if you need to do following visualization.\n# get a metanet\ngo &lt;- erdos.renyi.game(30, 0.25)\ngo &lt;- c_net_update(go)\npar(mfrow = c(1, 2))\nplot(go, vertex_size_range = c(5, 20), legend = F, main = \"Same size\")\n\n# calculate topological indexes and store\ngo &lt;- c_net_index(go)\nhead(get_v(go))\n##   name label size  v_group  shape  v_class   color Degree\n## 1    1     1    1 v_group1 circle v_class1 #a6bce3      9\n## 2    2     2    1 v_group1 circle v_class1 #a6bce3      9\n## 3    3     3    1 v_group1 circle v_class1 #a6bce3     12\n## 4    4     4    1 v_group1 circle v_class1 #a6bce3     12\n## 5    5     5    1 v_group1 circle v_class1 #a6bce3      8\n## 6    6     6    1 v_group1 circle v_class1 #a6bce3      8\n##   Clustering_coefficient Betweenness Eccentricity  Closeness Hub_score\n## 1              0.4444444    5.754127            3 0.01960784 0.7939083\n## 2              0.3888889    7.475959            3 0.02000000 0.7454913\n## 3              0.3030303   22.247461            2 0.02173913 0.9061033\n## 4              0.2727273   19.129754            2 0.02173913 0.9204176\n## 5              0.1785714   15.009456            2 0.02000000 0.4881289\n## 6              0.2142857   11.251368            3 0.01960784 0.5478093\n\n# use vertex.size to indicate degree\ngo &lt;- c_net_set(go, vertex_size = \"Degree\")\nplot(go, vertex_size_range = c(5, 20), legend = F, main = \"Size map to degree\")\n\n\n\n\n\n\nFigure 5.1: Topological indexes calculated by c_net_index()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Topology</span>"
    ]
  },
  {
    "objectID": "05-topology.html#random-network",
    "href": "05-topology.html#random-network",
    "title": "\n5  Topology\n",
    "section": "\n5.2 Random network",
    "text": "5.2 Random network\nYou can use rand_net() to generate a random graphs according to the Erdos-Renyi model with same node number and edge number of your network, then compare the random network with your network.\n\nrand_net(co_net) -&gt; random_net\n\n\n\n\n\n\nFigure 5.2: Comparison of complex network and random network degree distribution\n\n\n\n\nOr use rand_net_par() to generate lots of random networks and summary their topological indexes, then use compare_rand() to do the comparison.\n\nrand_net_par(co_net, reps = 30) -&gt; randp\nnet_par(co_net) -&gt; pars\ncompare_rand(pars, randp, index = c(\"Average_path_length\", \"Clustering_coefficient\"))\n\n\n\n\n\n\nFigure 5.3: Comparison of complex network and random network on some indexes.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Topology</span>"
    ]
  },
  {
    "objectID": "05-topology.html#complex-network",
    "href": "05-topology.html#complex-network",
    "title": "\n5  Topology\n",
    "section": "\n5.3 Complex network",
    "text": "5.3 Complex network\nMost of the networks we construct in omics research belong to complex networks, which generally has the following characteristics, scale-free, small-world, modularity and hierarchy, as shown in the table below.\n\n\n\nTable 5.3: Common characteristic of complex network\n\n\n\n\nTerminology\nExplanation\n\n\n\nScale-free\nScale-free It is a most notable characteristic in complex systems. It was used to desibe the finding that most nodes in a network have few neighbors while few nodes have large amount of neighbors. In most cases, the connectivity distribution asymptotically follows a power law. It can be expressed in , where $P(k) \\sim k^{-y}$ ,P(k) is the number of nodes with k degrees, k is connectivity/degrees andγis a constant.\n\n\nSmall-world\nSmall-world It is a terminology in network analyses to depict the average distance between nodes in a network is short, usually logarithmically with the total number of nodes. It means the network nodes are always closely related with each other.\n\n\nModularity\nThe modularity of a graph with respect to some division (or vertex types) measures how good the division is, or how separated are the different vertex types from each other. It defined as $Q=\\frac{1}{2m} \\sum_{i,j} (A_{ij}-\\gamma\\frac{k_i k_j}{2m})\\delta(c_i,c_j)$ ,here mm is the number of edges, $A_{ij}$ is the element of the A adjacency matrix in row i and column j, $k_i$ is the degree of i, $k_j$ is the degree of j, $c_i$ is the type (or component) of i, $c_j$ that of j, the sum goes over all i and j pairs of vertices, and $\\delta(x,y)$ is 1 if x=y and 0 otherwise. The resolution parameter $\\gamma$ allows weighting the random null model, which might be useful when finding partitions with a high modularity.The original definition of modularity is retrieved when setting $\\gamma$ to 1 @newmanModularityCommunityStructure2006.\n\n\nHierarchy\nHierarchy It was used to depict the networks which could be arranged into a hierarchy of groups representing in a tree structure. Several studies demonstrated that metabolic networks are usually accompanied by a hierarchical modularity.\n\n\n\n\n\n\n\n\nfit_power() is used to prove the scale-free property of a network, it will fit a power-law distribution to the degree distribution of the network.\n\ndata(\"c_net\", package = \"MetaNet\")\nfit_power(co_net)\n\n\n\n\n\n\nFigure 5.4: Fit power-law distribution for a network.\n\n\n\n\nsmallworldness() can calculate the smallworld index \\(\\sigma\\).\n\\[\n\\sigma=\\frac\\gamma\\lambda=\\frac{C/C_{random}}{L/L_{random}}\n\\]\nC and L are the clustering coefficient and average path length of the empirical network, and \\(C_{random}\\) and \\(L_{random}\\) are the clustering coefficient and average path length of the random network, respectively.\nIf \\(\\sigma\\) &gt; 1, the empirical network usually has the characteristics of a small-world network.\n\nsmallworldness(co_net)\n## 43.09368",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Topology</span>"
    ]
  },
  {
    "objectID": "05-topology.html#sec-modules",
    "href": "05-topology.html#sec-modules",
    "title": "\n5  Topology\n",
    "section": "\n5.4 Modules",
    "text": "5.4 Modules\nA community is a subgraph containing nodes which are more densely linked to each other than to the rest of the graph or equivalently, a graph has a community structure if the number of links into any subgraph is higher than the number of links between those subgraphs.\nUse module_net() to generate a n-modules network and do some modules analysis test.\n\ntest_module_net &lt;- module_net(module_number = 3, n_node_in_module = 30)\nplot(test_module_net, mark_module = T)\n\n\n\n\n\n\nFigure 5.5: A 3-modules network generated by module_net()\n\n\n\n\nModule detection\nThere are many algorithms to detect modules in a network, some of the most common algorithms include:\n\nshort random walks\nleading eigenvector of the community matrix\nsimulated annealing approach\ngreedy modularity optimization\n…\n\nYou can get network modules by module_detect() with various algorithms.\nBut we sometimes just focus on several modules instead of all, so we can use filter_n_module() to get modules which have more than n nodes, or keep some other modules by ids.\n\npar(mfrow = c(2, 2), mai = rep(1, 4))\n# module detection\nmodule_detect(co_net, method = \"cluster_fast_greedy\") -&gt; co_net_modu\nget_v(co_net_modu)[, c(\"name\", \"module\")] %&gt;% head()\n##                           name module\n## 1 s__un_f__Thermomonosporaceae     10\n## 2        s__Pelomonas_puraquae      9\n## 3     s__Rhizobacter_bergeniae      1\n## 4     s__Flavobacterium_terrae      3\n## 5         s__un_g__Rhizobacter     14\n## 6     s__un_o__Burkholderiales      9\n\nplot(co_net_modu,\n  plot_module = T, mark_module = T,\n  legend_position = c(-1.8, 1.6, 1.1, 1.3), edge_legend = F\n)\ntable(V(co_net_modu)$module)\n## \n##  1 10 11 12 13 14 15 16 17 18 19  2 20 21 22 23 24 25 26 27 28 29  3  4  5  6 \n## 36 18 35 16 17 12 21 15  6  4  4 24  2  3  2  2  2  2  3  2  3  2 27 23 35 23 \n##  7  8  9 \n## 33 18 61\n\n# keep some modules\nco_net_modu2 &lt;- filter_n_module(co_net_modu, n_node_in_module = 30, keep_id = 10)\nplot(co_net_modu2, plot_module = T, mark_module = T, legend_position = c(-1.8, 1.3, 1.1, 1.3))\n\n# change group layout\ng_layout_circlepack(co_net_modu, group = \"module\") -&gt; coors\nplot(co_net_modu2, coors = coors, plot_module = T, mark_module = T, edge_legend = F)\n\n# extract some modules, delete =T will delete other modules.\nco_net_modu3 &lt;- filter_n_module(co_net_modu, n_node_in_module = 30, keep_id = 10, delete = T)\nplot(co_net_modu3, coors, plot_module = T)\n\n\n\n\n\n\nFigure 5.6: Module detection results by module_detect()\n\n\n\n\nLook at the components of the network, some too small sub_graphs will effect the modules, if you do not care about these small components, you can just filter out them.\n\ntable(V(co_net_modu)$components)\n## \n##   1  10  11  12  13   2   3   4   5   6   7   8   9 \n## 418   2   2   2   2   6   4   2   2   3   2   3   3\nco_net_modu4 &lt;- c_net_filter(co_net_modu, components == 1)\n\n# re-do a module detection\nco_net_modu4 &lt;- module_detect(co_net_modu4)\ng_layout_circlepack(co_net_modu4, group = \"module\") -&gt; coors\nplot(co_net_modu4, coors, plot_module = T)\n\n\n\n\n\n\nFigure 5.7: Filter small components in a network\n\n\n\n\nUse plot_module_tree() can display the dendrogram relationship of nodes, and combine_n_module() can change the module numbers to a specific number (can not be too big or too small if there are some small small sub_graphs)\n\np1 &lt;- plot_module_tree(co_net_modu4, label.size = 0.6)\n# combine 17 modules to 5.\nco_net_modu5 &lt;- combine_n_module(co_net_modu4, 5)\np2 &lt;- plot_module_tree(co_net_modu5, label.size = 0.6)\np1 + p2\n\n\n\n\n\n\nFigure 5.8: Modules tree and combine 17 modules to 5\n\n\n\n\nWe could also use this network module indicates some cluster which have similar expression/abundance. But we should filter the positive edges firstly as the module detection only consider topology structure rather than the edge type. After filtering the positive edges and module detection will find some modules like WGCNA gene modules, and we can also get the “eigengene” using module_eigen() and have a general look at each module expression by module_expression().\n\ndata(\"otutab\", package = \"pcutils\")\ntotu &lt;- t(otutab)\n# filter positive edges\nc_net_filter(co_net, e_type == \"positive\", mode = \"e\") -&gt; co_net_pos\nco_net_pos_modu &lt;- module_detect(co_net_pos, n_node_in_module = 15, delete = T)\n\ng_layout_circlepack(co_net_pos_modu, group = \"module\") -&gt; coors1\nplot(co_net_pos_modu, coors1, plot_module = T)\n\n\n\n\n\n\nFigure 5.9: Filter positive modules\n\n\n\n\n\n# map the original abundance table\nmodule_eigen(co_net_pos_modu, totu) -&gt; co_net_pos_modu\n\n# plot the expression pattern\np1 &lt;- module_expression(co_net_pos_modu, totu,\n  r_threshold = 0.6,\n  facet_param = list(ncol = 4), plot_eigen = T\n) +\n  theme(axis.text.x = element_text(size = 5, angle = 90, vjust = 0.5))\n\n# correlate to metadata\nenv &lt;- metadata[, 3:8]\np2 &lt;- cor_plot(get_module_eigen(co_net_pos_modu), env) + coord_flip()\n\np1 / p2 + patchwork::plot_layout(heights = c(2, 1.4))\n\n\n\n\n\n\nFigure 5.10: Module eigenvalue of positive cluster\n\n\n\n\n\n# summary some variable according to modules.\np3 &lt;- summary_module(co_net_pos_modu, var = \"Phylum\") +\n  scale_fill_pc()\np4 &lt;- summary_module(co_net_pos_modu, var = \"node_eigen_cor\") +\n  scale_color_pc(palette = \"col2\")\np3 + p4\n\n\n\n\n\n\nFigure 5.11: Summary of some variables in each modules\n\n\n\n\nUse links_stat() to summary the edges and find most edges are from a module to the same module (means module detection is OK).\n\nlinks_stat(co_net_modu2, group = \"module\")\n\n\n\n\n\n\nFigure 5.12: Summary of edges in each modules\n\n\n\n\nKeystone\nAfter we determine these modules of network, the topological role of each node can be calculated according to Zi-Pi (1).\nWithin-module connectivity (Zi):\n\\[\nZ_i= \\frac{\\kappa_i-\\overline{\\kappa_{si}}}{\\sigma_{\\kappa_{si}}}\n\\]\nWhere \\(κ_i\\) is the number of links of node i to other nodes in its module si, \\(\\overline{\\kappa_{si}}\\) is the average of k over all the nodes in si, and \\(\\sigma_{\\kappa_{si}}\\) is the standard deviation of κ in si.\nAmong-module connectivity (Pi):\n\\[\nP_i=1-\\sum_{s=1}^{N_m}{\\left( {\\frac{\\kappa_{is}}{k_i}} \\right)^2}\n\\]\nwhere \\(\\kappa_{is}\\) is the number of links of node i to nodes in module s, and \\(k_i\\) is the total degree of node i.\nAnd researchers often divide module roles into four categories:\n\n\n\nTable 5.4: The topological role of individual node\n\n\n\n\n\nZi\nZi&gt;2.5\n\n\n\nPi\nperipherals\nmodule hubs\n\n\nPi&gt;0.62\nconnectors\nnetwork hubs\n\n\n\n\n\n\n\n\nAnd some articles define these nodes in red categories as keystone nodes of a network (2).\nUse zp_analyse() to get module roles and store in the vertex attributes, then we can use zp_plot() to visualize. We can see the module hubs are center of a module while connector are often mediate the connection of different modules.\n\nzp_analyse(co_net_modu4) -&gt; co_net_modu4\nget_v(co_net_modu4)[, c(1, 16:21)] %&gt;% head()\n##                           name components module original_module Ki         Zi\n## 1 s__un_f__Thermomonosporaceae          1      6               6  3  0.4358899\n## 2        s__Pelomonas_puraquae          1     11              11 15  1.9019177\n## 3     s__Rhizobacter_bergeniae          1      1               1  4  1.0951304\n## 4     s__Flavobacterium_terrae          1      3               3  4  1.8027756\n## 5         s__un_g__Rhizobacter          1     14              14  1 -1.0488088\n## 6     s__un_o__Burkholderiales          1     11              11 17  2.3326783\n##          Pi\n## 1 0.3750000\n## 2 0.3490305\n## 3 0.5714286\n## 4 0.0000000\n## 5 0.0000000\n## 6 0.1939058\n# color map to roles\nco_net_modu6 &lt;- c_net_set(co_net_modu4, vertex_class = \"roles\")\nplot(co_net_modu6, coors, mark_module = T, labels_num = 0, group_legend_title = \"Roles\")\n\n\n\n\n\n\nFigure 5.13: Nodes roles of a modular network\n\n\n\n\n\nlibrary(patchwork)\nzp_plot(co_net_modu4, mode = 1) +\n  zp_plot(co_net_modu4, mode = 3)\n\n\n\n\n\n\nFigure 5.14: Zi-Pi analysis of a modular network\n\n\n\n\n\n\n\n\n1. \nR. Guimerà, L. Amaral, Functional cartography of complex metabolic networks (2005), doi:10.1038/nature03288.\n\n\n2. \nS. Liu, H. Yu, Y. Yu, J. Huang, et al., Ecological stability of microbial communities in Lake Donghu regulated by keystone taxa. Ecological Indicators. 136, 108695 (2022).",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Topology</span>"
    ]
  },
  {
    "objectID": "06-stability.html",
    "href": "06-stability.html",
    "title": "\n6  Stability\n",
    "section": "",
    "text": "6.1 Network construction\nIt is very important to compare networks stability based on different groups.\nFor example, we have three groups of samples: NS, WS, CS, n=6 (in real research, n should be bigger for a meaningful result), we can construct three group networks for each group and compare them.\ndata(\"otutab\", package = \"pcutils\")\n\ntable(metadata$Group)\n## \n## NS WS CS \n##  6  6  6\n# check all rows matched\nall(colnames(otutab) == rownames(metadata))\n## [1] TRUE\n# extract three-group sub-nets\nhebing(otutab, metadata$Group) -&gt; otutab_G\nhead(otutab_G)\n\n# whole network\nt(otutab) -&gt; totu\nc_net_calculate(totu) -&gt; corr\nc_net_build(corr, r_threshold = 0.65) -&gt; co_net\n\ngroup_net_par &lt;- extract_sample_net(co_net, otutab_G, save_net = \"../Group_subnet\")\ngroup_nets &lt;- readRDS(\"../Group_subnet.RDS\")\n\nnames(group_nets)\ndata(\"otutab\", package = \"pcutils\")\n\ntotu &lt;- t(otutab)\n# check all rows matched\nall(rownames(totu) == rownames(metadata))\n\n# Use RMT threshold or not?\nrmt &lt;- FALSE\ngroup_nets &lt;- lapply(levels(metadata$Group), \\(i){\n  totu[rownames(filter(metadata, Group == !!i)), ] -&gt; t_tmp\n  t_tmp[, colSums(t_tmp) &gt; 0] -&gt; t_tmp\n  c_net_calculate(t_tmp) -&gt; c_tmp\n  if (rmt) {\n    RMT_threshold(c_tmp, verbose = F, out_dir = \"test/\") -&gt; tmp_rmt\n    r_thres &lt;- tmp_rmt$r_threshold\n  } else {\n    r_thres &lt;- 0.6\n  }\n  c_net_build(c_tmp, r_threshold = r_thres, p_threshold = 0.01, delete_single = T) -&gt; n_tmp\n  Abundance_df &lt;- data.frame(\"Abundance\" = colSums(t_tmp))\n  c_net_set(n_tmp, Abundance_df, taxonomy %&gt;% select(\"Phylum\"), vertex_class = \"Phylum\", vertex_size = \"Abundance\")\n})\n\nnames(group_nets) &lt;- levels(metadata$Group)\nAll calculation for network stability provide parallel version, use parallel::detectCores() to get you device cores and set threads &gt;1 to use parallel calculation.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Stability</span>"
    ]
  },
  {
    "objectID": "06-stability.html#network-construction",
    "href": "06-stability.html#network-construction",
    "title": "\n6  Stability\n",
    "section": "",
    "text": "We can extract three-group sub-nets from the whole network:\n\n\n\nOr construct a network for each group specifically:",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Stability</span>"
    ]
  },
  {
    "objectID": "06-stability.html#robust-test",
    "href": "06-stability.html#robust-test",
    "title": "\n6  Stability\n",
    "section": "\n6.2 Robust test",
    "text": "6.2 Robust test\nRobust test of networks were done with natural connectivity as it can reflect the stability of networks (1).\nSpecifically, natural connectivity was calculated after removing the nodes (remove five nodes from a network at one time until 70% of nodes disappear), and the downtrend level of natural connectivity indicated the connectivity performance of the network after being damaged to a certain extent.\n\n# recommend `reps` bigger than 99, you can set `threads &gt;1` to use parallel calculation.\nrobust_test(group_nets, partial = 0.5, step = 10, reps = 9, threads = 1) -&gt; robust_res\nplot(robust_res, mode = 2)\n\n\n\n\n\n\n\n\nFigure 6.1: Robust test result",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Stability</span>"
    ]
  },
  {
    "objectID": "06-stability.html#community-stability",
    "href": "06-stability.html#community-stability",
    "title": "\n6  Stability\n",
    "section": "\n6.3 Community stability",
    "text": "6.3 Community stability\nCommunity stability can be characterized by various indexes, such as robustness, vulnerability and cohesion. Networks with higher robustness and lower vulnerability tend to be more stable (2). Also, community stability is commonly associated with negative interactions, and high percentage of negative correlations within communities is essential for maintaining a stable ecological system.\nRobustness\nThe robustness was regarded as when 50% of nodes were randomly removed and results were based on repetitions of the simulation.\nRobustness of a network is defined as the proportion of the remaining nodes in this network after random node removal. For simulations of random nodes removal, a certain proportion of nodes was randomly removed. To test the effects of nodes removal on the remaining nodes, we calculated the abundance-weighted mean interaction strength (wMIS) of node i as follows:\n\\[\n\\mathrm{wMIS}_i=\\frac{\\sum_{j\\neq i}b_js_{ij}}{\\sum_{j\\neq i}b_j}\n\\]\nwhere bj is the relative abundance of species j and sij is the association strength between species i and j, which is measured by Pearson correlation coefficient. Thus, in this study, sij = sji. After removing the selected nodes from the MEN, if wMISi = 0 (all the links to species i have been removed) or wMISi &lt; 0 (not enough mutualistic association between species i and other species for its survival), node i was considered extinct/isolated and thus removed from the network. This process continued until all species had positive wMISs. The proportion of the remaining nodes was reported as the network robustness. We measured the robustness when 50% of random nodes or five module hubs were removed.\n\n# recommend reps bigger than 99, you can set `threads &gt;1` to use parallel calculation.\nrobustness(group_nets, keystone = F, reps = 99, threads = 1) -&gt; robustness_res\nplot(robustness_res, p_value2 = T)\n\n\n\n\n\n\n\n\nFigure 6.2: Robustness simulation result\n\n\n\n\nVulnerability\nTo evaluate the speed of disturbance spreading within a network, the global efficiency was regarded as the average of the efficiency over all pairs of nodes, which was calculated by the number of edges in the shortest path between paired nodes.\nThe vulnerability, which reflected the relative contribution of each node to the globe efficiency, was represented by the maximal vulnerability of nodes in the network.\n\\[\n\\max\\left(\\frac{E-E_i}E\\right)\n\\]\nwhere E is the global efficiency and Ei is the global efficiency after removing node i and its entire links. The global efficiency of a graph was calculated as the average of the efficiencies over all pairs of nodes:\n\\[\nE=\\frac1{n(n-1)}\\sum_{i\\neq j}\\frac1{d(i,j)}\n\\] where d(i, j) is the shortest path length between nodes i and j. The vulnerability was defined as the maximal vulnerability of nodes in the network.\n\n# You can set `threads &gt;1` to use parallel calculation.\nvulnerability_res &lt;- vulnerability(group_nets, threads = 1)\nplot(vulnerability_res)\n\n\n\n\n\n\n\n\nFigure 6.3: Vulnerability calculate result.\n\n\n\n\nCohesion\nCohesion was calculated to quantify the connectivity of microbial communities in each group. Cohesion contains both positive and negative cohesion values, which indicate that associations between taxa attributed to positive and negative species interactions as well as similarities and differences in niches of microbial taxa (3).\nBriefly, pairwise Pearson correlation matrix across taxa was calculated based on abundance-weighted matrix. After “taxa shuffle” null module-correcting with 200 simulations, average positive and negative correlations was calculated to get a connectedness matrix. Finally, positive and negative cohesions were calculated for each sample respectively by multiplying the abundance-weighted matrix and connectedness matrix. The absolute value of negative: positive cohesion is an important index for community stability.\n\\[\n\\text{Cohesion}=\\sum_{i=1}^n\\text{abundance}_i\\times\\text{connectednes}s_i\n\\]\n\n# recommend reps bigger than 199, you can set `threads &gt;1` to use parallel calculation.\nCohesion(otutab, reps = 9, threads = 1) -&gt; cohesion_res\np1 &lt;- plot(cohesion_res, group = \"Group\", metadata, mode = 1) + theme_bw()\np2 &lt;- plot(cohesion_res, group = \"Group\", metadata, mode = 2)\np1 + p2\n\n\n\n\n\n\n\n\nFigure 6.4: Cohesion result.\n\n\n\n\n\n\n\n\n1. \nM. B. WU Jun, Natural Connectivity of Complex Networks. Chinese Physics Letters. 27, 78902–078902 (2010).\n\n\n2. \nM. M. Yuan, X. Guo, L. Wu, Y. Zhang, et al., Climate warming enhances microbial network complexity and stability. Nature Climate Change. 11, 343–348 (2021).\n\n\n3. \nC. M. Herren, K. McMahon, Cohesion: A method for quantifying the connectivity of microbial communities (2017), doi:10.1038/ismej.2017.91.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Stability</span>"
    ]
  },
  {
    "objectID": "07-multi-omics.html",
    "href": "07-multi-omics.html",
    "title": "7  Multi-omics",
    "section": "",
    "text": "7.1 Case study\nIn-depth multi-omic profiling was performed on each sample including plasma proteomics (targeted and untargeted), metabolomics (untargeted), lipidomics (semi-targeted), and gene expression (transcriptomics) from peripheral blood mononuclear cells (PBMCs) (1).\nFigure 7.1: Overview of the study design including an acute bout of exercise",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Multi-omics</span>"
    ]
  },
  {
    "objectID": "07-multi-omics.html#case-study",
    "href": "07-multi-omics.html#case-study",
    "title": "7  Multi-omics",
    "section": "",
    "text": "1. \nK. Contrepois, S. Wu, K. J. Moneghetti, D. Hornburg, et al., Molecular Choreography of Acute Exercise. Cell. 181, 1112–1130.e16 (2020).",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Multi-omics</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "1. K.\nContrepois, S. Wu, K. J. Moneghetti, D. Hornburg, et al., Molecular\nChoreography of Acute Exercise.\nCell. 181, 1112–1130.e16 (2020).\n\n\n2. Y.\nDeng, Y. Jiang, Y. Yang, Z. He, et al., Molecular ecological\nnetwork analyses. BMC bioinformatics (2012), doi:10.1186/1471-2105-13-113.\n\n\n3. K.\nFaust, J. Raes, Microbial interactions: From networks to models.\nNature Reviews Microbiology (2012), doi:10.1038/nrmicro2832.\n\n\n4. R.\nGuimerà, L. Amaral, Functional cartography of complex metabolic networks\n(2005), doi:10.1038/nature03288.\n\n\n5. C.\nM. Herren, K. McMahon, Cohesion: A method for quantifying the\nconnectivity of microbial communities (2017), doi:10.1038/ismej.2017.91.\n\n\n6. S.\nLiu, H. Yu, Y. Yu, J. Huang, et al., Ecological\nstability of microbial communities in Lake Donghu regulated\nby keystone taxa. Ecological Indicators.\n136, 108695 (2022).\n\n\n7. M.\nB. WU Jun, Natural\nConnectivity of Complex Networks.\nChinese Physics Letters. 27, 78902–078902\n(2010).\n\n\n8. M.\nM. Yuan, X. Guo, L. Wu, Y. Zhang, et al., Climate warming\nenhances microbial network complexity and stability. Nature\nClimate Change. 11, 343–348 (2021).",
    "crumbs": [
      "References"
    ]
  }
]